<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java EE 简介</title>
      <link href="/2023/09/01/java-ee-introduction/"/>
      <url>/2023/09/01/java-ee-introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-EE-层级架构">Java EE 层级架构</h2><p><img src="/img/java/Java_EE_architecture.webp" alt="Java EE 架构"></p><p>总体上来说，Java EE 是一个 3 层架构：表现层、业务层、数据访问层。<strong>Java EE 的核心是 JSP、Servlet、EJB</strong>。</p><h2 id="The-Java-EE-7-stack">The Java EE 7 stack</h2><p><img src="/img/java/Java_EE_Architecture_Diagram.PNG" alt="Java EE Architecture Diagram"></p><p>Java EE 的参考实现是：<strong>Glassfish Application Server</strong>。除此之外，流行的还有 TomEE、WebSphere、WebLogic、JBoss 等等。</p><h3 id="Web-容器">Web 容器</h3><p>Web 容器是 Java EE 环境的一部分，专用于运行那些 Web 组件，如：pages 网页、JSP、Servlet、JSTL 及其他 Java EE Web 组件。Web 容器可通过标准 Web 连接到 Java EE 应用程序的<strong>客户端</strong>进行交互协议，当然更可以使用 Http、WebSocket 等公开协议。</p><p>在 Java EE 中，纯 Web 容器一般只有三种：Tomcat、Jetty、Undertow。其它的如 Glassfish、Weblogic 等属于应用服务器，包含了 Web 的功能。</p><p>Web 容器/服务器有着比应用服务器更加轻量级的特点，随着 Spring 成为主流技术也让轻量级的 Web 容器更加受到青睐，最具代表性的当属 Tomcat。</p><p>Tomcat 是 Apache 软件基金会的 Jakarta 项目中的一个<strong>核心项目</strong>。由 Apache、Sun 和其他一些公司及个人共同开发而成，由于有了 Sun 的参与（现在 Oracle）和支持，Tomcat 总是能最及时的支持到最新版的 Servlet/JSP 技术规范。</p><h3 id="EJB容器">EJB容器</h3><p>EJB 容器是 Java EE 环境的一部分，专用于<strong>运行 Java EE 应用程序</strong>的应用程序逻辑部分。EJB 是包含和操纵 Java EE 应用程序的核心数据结构的 Java 类。</p><p>Spring 容器的功能跟它很类似。然后 EJB 容易由于它过重的设计，现在已经败下阵来，成为了 Spring 的天下。</p><p>值得强调的是：Tomca t 是不包含 EJB 容器的（无 Java EE 运行环境），不过他“哥哥”Tom EE 有，是个完整的应用服务器。</p><h3 id="Java-EE-十三种常用的核心技术规范：">Java EE 十三种常用的核心技术规范：</h3><p><a href="https://stackoverflow.com/questions/37082364/a-summary-of-all-java-ee-specifications">jakarta ee - A summary of all Java EE specifications - Stack Overflow</a> 总结了 Java EE 的规范。</p><p><img src="/img/java/Java_EE_7_stack.PNG" alt="Java EE 7 Stack"></p><ul><li><p><strong>JDBC (Java Database Connectivity)</strong><br>JDBC API 为访问不同的数据库提供了一种统一的途径，象 ODBC 一样，JDBC 对开发者屏蔽了一些细节问题，另外，JDBC 对数据库的访问也具有平台无关性。</p></li><li><p><strong>JNDI (Java Name and Directory Interface)</strong><br>JNDI API 被用于执行名字和目录服务。它提供了一致的模型来存取和操作企业级的资源如 DNS 和 LDAP，本地文件系统，或应用服务器中的对象。</p></li><li><p><strong>EJB (Enterprise JavaBean)</strong><br>J2EE 技术之所以赢得媒体广泛重视的原因之一就是 EJB。它们提供了一个框架来开发和实施分布式商务逻辑，由此很显著地简化了具有可伸缩性和高度复杂的企业级应用的开发。EJB 规范定义了 EJB 组件在何时如何与它们的容器进行交互作用。容器负责提供公用的服务，例如目录服务、事务管理、安全性、资源缓冲池以及容错性。但这里值得注意的是，EJB 并不是实现 J2EE 的唯一途径。正是由于 J2EE 的开放性，使得有的厂商能够以一种和 EJB 平行的方式来达到同样的目的。</p></li><li><p><strong>RMI (Remote Method Invoke)</strong><br>调用远程对象上的方法。它使用了序列化方式在客户端和服务器端传递数据。RMI 是一种被 EJB 使用的更底层的协议。</p></li><li><p><strong>Java IDL/CORBA</strong><br>在 Java IDL 的支持下，开发人员可以将 Java 和 CORBA 集成在一起。他们可以创建 Java 对象并使之可在 CORBA ORB 中展开，或者他们还可以创建 Java 类并作为和其它 ORB 一起展开的 CORBA 对象的客户。后一种方法提供了另外一种途径，通过它 Java 可以被用于将你的新的应用和旧的系统相集成。</p></li><li><p><strong>JSP (Java Server Pages)</strong><br>JSP 页面由 HTML 代码和嵌入其中的 Java 代码所组成。服务器在页面被客户端所请求以后对这些 Java 代码进行处理，然后将生成的 HTML 页面返回给客户端的浏览器。</p></li><li><p><strong>Java Servlet</strong><br>Servlet 是一种小型的 Java 程序，它扩展了 Web 服务器的功能。作为一种服务器端的应用，当被请求时开始执行，这和 CGI Perl 脚本很相似。Servlet 提供的功能大多与 JSP 类似，不过实现的方式不同。JSP 通常是大多数 HTML 代码中嵌入少量的 Java 代码，而 servlets 全部由 Java 写成并且生成 HTML。</p></li><li><p><strong>XML (Extensible Markup Language)</strong><br>XML 是一种可以用来定义其它标记语言的语言。它被用来在不同的商务过程中共享数据。<br>XML 的发展和 Java 是相互独立的，但是，它和 Java 具有的相同目标正是平台独立性。通过将 Java 和 XML 的组合，您可以得到一个完美的具有平台独立性的解决方案。</p></li><li><p><strong>JMS (Java Message Service)</strong><br>JMS 是用于和面向消息的中间件相互通信的应用程序接口（API）。它既支持点对点的域，又支持发布/订阅（publish/subscribe）类型的域，并且提供对下列类型的支持：经认可的消息传递，事务型消息的传递，一致性消息和具有持久性的订阅者支持。JMS 还提供了另一种方式来对您的应用与旧的后台系统相集成。</p></li><li><p><strong>JTA (Java Transaction Architecture)</strong><br>JTA 定义了一种标准的 API，应用系统由此可以访问各种事务监控。</p></li><li><p><strong>JTS (Java Transaction Service)</strong><br>JTS 是 CORBA OTS 事务监控的基本的实现。JTS 规定了事务管理器的实现方式。该事务管理器是在高层支持 Java Transaction API (JTA）规范，并且在较底层实现 OMG OTS specification 的 Java 映像。JTS 事务管理器为应用服务器、资源管理器、独立的应用以及通信资源管理器提供了事务服务。</p></li><li><p><strong>JavaMail</strong><br>JavaMail 是用于存取邮件服务器的 API，它提供了一套邮件服务器的抽象类。不仅支持 SMTP 服务器，也支持 IMAP 服务器。</p></li><li><p><strong>JAF (JavaBeans Activation Framework)</strong><br>JavaMail 利用 JAF 来处理 MIME 编码的邮件附件。MIME 的字节流可以被转换成 Java 对象，或者转换自 Java 对象。大多数应用都可以不需要直接使用 JAF。</p></li></ul><h2 id="EJB-的缺陷">EJB 的缺陷</h2><p>早期的 Java EE 平台（ J2EE ） 是推崇以 EJB 为核心的开发方式，这种方式存在以下几个弊端：</p><ol><li><p>没有面向实际问题：J2EE 和 EJB 的很多问题都源自它们“以规范为驱动”的本质。标准委员会所指定的规范，并没有针对性地解决问题，反而在实际开发中引人很多复杂性。毕竟，成功的标准都是从实践中发展来的，而不是由哪个委员会创造出来的。</p></li><li><p>应反“帕累托法则”： “ 帕累托法则”也称“二八定律”，是指花较少的（ 10%～20% ）的成本解决大部分问题（ 80%～90% ），而架构的价值在于为常见的问题找到好的解决方案，而不是一心想要解决更复杂、也更为罕见的问题。 EJB 的问题就在于，它违背了这个法则一一为了满足少数情况下的特殊要求，它给大多数使用者强加上了不必要的复杂性。</p></li><li><p>引人重复代码：大多数 J2EE 代码生成工具所生成的代码都是用于实现 J2EE 经典架构的，这会导致引人很多重复代码、过渡工程等问题。</p></li><li><p>目标定位不清晰：早期的 EJB 2.1 规范中 EJB 的目标定位有 11 项之多。而这些目标，没有一项是致力于简化 Java EE 开发的。</p></li><li><p>编程模型复杂： EJB 组成复杂，要使用 EJB 需要继承非常多的接口。而这些接口，在实际开发中并不是真正为了解决问题。</p></li><li><p>开发周期长： EJB 依赖于容器，所以 EJB 在编写业务逻辑时，是与容器耦合的。这必然就导致开发、测试、部署的难度增大。同时，也拉长了整个开发的周期。</p></li><li><p>移植困难：规范中定义的目标是“Write Once, Run Anywhere”，但实际上这基本是一句空话。结果变成了一次编写，到处重写。特别是实体 Bean ，基本上迁移了一个服务器，就相当于需要重新编写，相应的测试工作量也增加了。规范中对实体映射的定义太过于宽泛，导致每个厂商都有自己的 ORM 实现，引入特定厂商的部署描述符，又因为 J2EE 中除 Web 外，类加载的定义没有明确，导致产生了特定厂商的类加载机制和打包方式。同时，特定厂商的服务查找方式也是有差异的。</p></li></ol><p>当然，Java EE 也在持续改进现代软件所需的 API 和编程模型，并创建其社区所需的功能。其中一些功能包括异步 CDI 事件、增强的 JSON 支持、新的 REST 反应式客户端 API 等等。EJB 也在不断发展，解决了上述提到的一些问题。</p><h2 id="Spring-框架的诞生">Spring 框架的诞生</h2><p>面对 Java EE 的沉重，大量对 Java EE 不满（尤其是 EJB）的“草根”程序员们，集结在开源社区下，发起一场旨在使用“轻量级”技术以代替复杂 EJB 的运动。其中，最耀眼的两颗明星正是今天大名鼎鼎的 Spring 和 Hibernate。</p><p>“ Spring 之父” Rod Johnson 对传统的 Java EE 系统框架臃肿、低效、脱离现实的种种现状提出了质疑，并积极寻求探索革新。 2005 年，Rod Johnson 的新书《J 2 EE Development without EJB》出版。在中这本书中，Rod Johnson 不仅列举了 EJB 的困境，而且还在理论上阐释了如何破解困境，然后基于理论，推出了具体的 Spring 和 Hibernate 作为终极解决方案。</p><p>EJB 困境的根源在于复杂，因此要解决 EJB 的困境，必须让对象回归本质，用 POJO（简单 Java 对象）替代 EJB，用 Spring 代替 EJB 容器。依赖 Spring 的 IOC（控制发展）、DI（依赖注入）、AOP（面向切面编程）能力，来消解 EJB 容器承担的诸多功能。其次，单独引入 Hibernate，来解决 EJB 想解决，但从未成功的对象持久化问题。</p><p>后来的实践证明，Spring + Hibernate 的轻量组合，不仅完全可以替代 EJB，而且还具备简单高效的额外优点。所以很快，在 Java EE 开发中，Spring + Hibernate 组合就完全取代了 EJB，成为事实上的标准。</p><p>虽然 Spring 喊出了“Without EJB”的口号。实际上 Spring 是对 Java EE 的改进和补充。 Spring 本身也集成非常多的 Java EE 平台规范，如 Servlet API ( JSR 340 ）、WebSocket API ( JSR 356 ）、Concurrency Utilities ( JSR 236 ）、JSON Binding API ( JSR 367 ）、Bean Validation ( JSR 303 ） 、JPA ( JSR 338 ）、JMS ( JSR 914 ）、Dependency Injection (JSR 330 ）、Common Annotations ( JSR 250 ）等。</p><p>Spring 框架组件：</p><p><img src="/img/java/spring-overview.png" alt="Spring Framework Overview"></p><p>Spring 的主要特性：</p><ol><li>轻量级 IoC 容器：IoC 容器是用于管理所有 bean 的声明周期，是 Spring 的核心组件。在此基础之上，开发者可以自行选择要集成的组件，如消息传递、事务管理、数据持久化及 Web 组件等。</li><li>采用 AOP 编程方式：Spring 推崇使用 AOP 编程方式。 AOP ( Aspect Oriented Programming，面向切面编程）的目标与 OOP ( Object Oriented Programming ，面向对象编程）的目标并没有不同，都是为了减少重复和专注于业务。</li><li>大量使用注解： Spring 提供了大量的注解，支持声明式的注入方式，极大地简化了配置。</li><li>避免重复 “造轮子”：Spring 集成了大量市面上成熟的开源组件，站在巨人的肩膀上，这样既增强了 Spring 的功能，又避免了重复 “造轮子” 。</li></ol><p>相比于经典的 Java EE 架构：</p><ol><li>前端：applet 被 ajax 替代，Java 桌面程序式弱，浏览器成为主流。</li><li>中间：web 服务器的职责进一步清晰，仅承担服务前端的职责，同时轻量级的 Spring 容器也被引入。</li><li>后端：1）应用服务器以 web service 的形式被外部调用，web 容器被引入；2）spring 容器替换了沉重的 EJB 容器；3）引入 Hibernate 来完成 Bean 的持久化。</li></ol><p>随着分布式技术、微服务、前后端分离等理念的提出，Java EE 进最终演变成今天的样子：</p><ol><li>因为前后端分离，Web 服务器不再负责页面的渲染，JSP 被淘汰。</li><li>MVC 被引入，先是 Structs，后 Structs 被 Spring MVC 替代。</li><li>更加敏捷的 MyBatis 越来越受欢迎，成为和 Hibernate 并立的两个主流持久化框架。</li><li>分布式架构成为主流，原来位于应用服务器的功能组件被拆分到单独的服务器中，从而使应用服务器的定位更加明晰。</li></ol><p><img src="/img/java/introduction-software-framework.png" alt="Software Framework"></p><h2 id="参考资料">参考资料</h2><p>[1]  Java EE 7 Essentials<br>[2]  <a href="https://www.cnblogs.com/xingzc/p/5759915.html">J2EE的13种核心技术 - bcombetter - 博客园</a><br>[3]  Java™ Platform, Enterprise Edition  (Java EE) Specification, v 7<br>[4]  <a href="https://yourbatman.cn/x2y/9f826227.html">什么是Java EE？ | YourBatman</a><br>[5]  《Spring 5 开发大全》- 柳伟卫<br>[6]  <a href="https://data-flair.training/blogs/spring-framework-tutorial/">Spring Framework Tutorial for Beginners - Learn Spring - DataFlair</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 发展历史</title>
      <link href="/2023/08/31/java-development-history/"/>
      <url>/2023/08/31/java-development-history/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-技术体系">Java 技术体系</h2><p>JCP 官方所定义的 Java 技术体系包括了以下几个组成部分：</p><ul><li>Java 程序设计语言</li><li>各种硬件平台上的 Java 虚拟机</li><li>Class 文件格式</li><li>Java API 类库</li><li>商业机构和开源社区的第三方 Java 类库</li></ul><blockquote><p><strong>JCP</strong>（<strong>Java Community Process</strong>）成立于1998年，是使有兴趣的各方参与定义<a href="https://zh.wikipedia.org/wiki/Java">Java</a>的特征和未来版本的正式过程。</p><p>JCP 使用 <strong>JSR</strong>（Java 规范请求，<em>Java Specification Requests</em>）作为正式规范文档，描述被提议加入到 Java 体系中的的规范和技术。</p></blockquote><blockquote><p>The JCP process defines three key deliverables for any JSR:</p><p><strong>Specification</strong><br>A formal document that describes the proposed component and its features.</p><p><strong>Reference Implementation (RI)</strong><br>Binary implementation of the proposed specification. The RI helps to ensure that the proposed specifications can be implemented in a binary form and provides constant feedback to the specification process.<br>The RI of Java EE is built in the GlassFish community.</p><p><strong>Technology Compliance Kit (TCK)</strong><br>A set of tests that verify that the RI is in compliance with the specification. This allows multiple vendors to provide compliant implementations.</p></blockquote><h2 id="Java-的发展历史">Java 的发展历史</h2><p><img src="/img/java/Java_history.png" alt="Java 发展历史"></p><p><strong>JDK 1.0发布</strong></p><p>1996年1月23日，JDK 1.0发布，Java语言有了第一个正式版本的运行环境。JDK 1.0提供了一个纯解释执行的Java虚拟机实现（Sun Classic VM）。JDK 1.0版本的代表技术包括：<strong>Java虚拟机、Applet、AWT等</strong>。</p><p><strong>JDK 1.1发布</strong></p><p>1997年2月19日，Sun公司发布了JDK 1.1，Java里许多最基础的技术支撑点（如JDBC等）都是在JDK 1.1版本中提出的，<strong>JDK 1.1版的技术代表有：JAR文件格式、JDBC、JavaBeans、RMI等。Java语言的语法也有了一定的增强，如内部类（Inner Class）和反射（Reflection）都是在这时候出现的</strong>。</p><p><strong>JDK 1.2发布</strong></p><p>1998年12月4日，JDK迎来了一个里程碑式的重要版本：工程代号为Playground（竞技场）的JDK 1.2。</p><p>Sun在这个版本中把Java技术体系拆分为三个方向，分别是面向桌面应用开发的J2SE（Java 2 Platform，StandardEdition）、面向企业级开发的J2EE（Java 2 Platform，Enterprise Edition）和面向手机等移动终端开发的J2ME（Java 2 Platform，Micro Edition）。</p><blockquote><p>J2EE在JDK 10以后被Oracle认为是一个不赚钱的业务，捐献给Eclipse基金会管理，但是不允许使用Java商标，所以改称为Jakarta EE。</p></blockquote><p>在这个版本中出现的代表性技术非常多，<strong>如EJB、Java Plug-in、Java IDL、Swing等，并且这个版本中Java虚拟机第一次内置了JIT（Just In Time）即时编译器</strong>（JDK 1.2中曾并存过三个虚拟机，Classic VM、HotSpot VM和Exact VM，其中Exact VM只在Solaris平台出现过；后面两款虚拟机都是内置了JIT即时编译器的，而之前版本所带的Classic VM只能以外挂的形式使用即时编译器）。<strong>在语言和API层面上，Java添加了strictfp关键字，Java类库添加了现在Java编码之中极为常用的一系列Collections集合类等。</strong></p><p><strong>JDK 1.3发布</strong></p><p>2000年5月8日，工程代号为Kestrel（美洲红隼）的JDK 1.3发布。<strong>相对于JDK1.2，JDK 1.3的改进主要体现在Java类库上（如数学运算和新的Timer API等），JNDI服务从JDK 1.3开始被作为一项平台级服务提供（以前JNDI仅仅是一项扩展服务），使用CORBA IIOP来实现RMI的通信协议，等等</strong>。这个版本还对Java 2D做了很多改进，提供了大量新的Java 2D API，并且新添加了JavaSound类库。</p><p><strong>JDK 1.4发布</strong></p><p>2002年2月13日，JDK 1.4发布，工程代号为Merlin（灰背隼）。JDK 1.4是标志着Java真正走向成熟的一个版本，Compaq、Fujitsu、SAS、Symbian、IBM等著名公司都有参与功能规划，甚至实现自己独立发行的JDK 1.4。哪怕是在近二十年后的今天，仍然有一些主流应用能直接运行在JDK 1.4之上，或者继续发布能运行在1.4上的版本。<strong>JDK 1.4同样带来了很多新的技术特性，如正则表达式、异常链、NIO、日志类、XML解析器和XSLT转换器，等等</strong>。</p><p><strong>JDK 1.4发布</strong></p><p>2002年2月13日，JDK 1.4发布，工程代号为 Merlin（灰背隼）。JDK 1.4是标志着 Java 真正走向成熟的一个版本，Compaq、Fujitsu、SAS、Symbian、IBM 等著名公司都有参与功能规划，甚至实现自己独立发行的 JDK 1.4。哪怕是在近二十年后的今天，仍然有一些主流应用能直接运行在 JDK 1.4之上，或者继续发布能运行在1.4上的版本。<strong>JDK 1.4同样带来了很多新的技术特性，如正则表达式、异常链、NIO、日志类、XML 解析器和 XSLT 转换器，等等</strong>。</p><p><strong>JDK 5发布</strong></p><p>2004年9月30日，JDK 5发布，工程代号为 Tiger（老虎）。Sun 公司从这个版本开始放弃了谦逊的“JDK 1.x”的命名方式，将产品版本号修改成了“JDK x”。<strong>从 JDK 1.2以来，Java 在语法层面上的变动一直很小，而 JDK 5在 Java 语法易用性上做出了非常大的改进。如：自动装箱、泛型、动态注解、枚举、可变长参数、遍历循环（foreach 循环）等语法特性都是在 JDK 5中加入的。在虚拟机和 API 层面上，这个版本改进了 Java 的内存模型（Java Memory Model，JMM）、提供了 java.util.concurrent 并发包等</strong>。另外，JDK 5是官方声明可以支持 Windows 9x 操作系统的最后一个 JDK 版本。</p><p><strong>JDk 6发布</strong></p><p>2006年12月11日，JDK 6发布，工程代号为 Mustang（野马）。</p><p>在这个版本中，Sun 公司终结了从 JDK 1.2开始已经有八年历史的 J2EE、J2SE、J2ME 的产品线命名方式，启用 Java EE 6、Java SE 6、Java ME 6的新命名来代替。</p><p><strong>JDK 6的改进包括：提供初步的动态语言支持（通过内置 Mozilla JavaScript Rhino 引擎实现）、提供编译期注解处理器和微型 HTTP 服务器 API，等等。同时，这个版本对 Java 虚拟机内部做了大量改进，包括锁与同步、垃圾收集、类加载等方面的实现都有相当多的改动</strong>。</p><blockquote><p>JDK 6发布后，Sun 公司把 Java 开源了，形成了 OpenJDK 项目。OpenJDK 和 JDK 的代码基本一致，除了极少量的产权代码（Encumbered Code，这部分代码所有权不属于 Sun 公司，Sun 本身也无权进行开源处理）外，OpenJDK 几乎拥有了当时 JDK 的全部代码。</p><p>我们可以这样简单理解两者的关系。JDK 的的代码是 master 主分支上的代码，openJDK 是从 master 上拉出来的一个产品线，在这个分支上删除了 Encumbered Code 等这些产权代码。所以如果你用不到这些产权特性的话，JDK 和 OpenJDK 可以认为是一致的。</p></blockquote><p><strong>JDK 7发布</strong></p><p>在 JDK 7发布之前，Java 的老东家 Sun 公司被 Oracle 收购了。在原本计划在 JDK 7中发布的很多特性不能如期完成。</p><p>为了保证如期发布 JDK 7，Oracle 大幅裁剪了 JDK 7预定目标，以保证 JDK 7的正式版能够于2011年7月28日准时发布。主要措施是把不能按时完成的 Lambda 项目、Jigsaw 项目和 Coin 项目的部分改进延迟到 JDK 8之中。</p><p>最终，<strong>JDK 7包含的改进有：提供新的 G1收集器（G1在发布时依然处于 Experimental 状态，直至2012年4月的 Update 4中才正式商用）、加强对非 Java 语言的调用支持（JSR-292，这项特性在到 JDK 11还有改动）、可并行的类加载架构等</strong>。</p><p><strong>JDK 8发布</strong></p><p>2014年3月18日，JDK 8发布。从 JDK 8开始，Oracle 启用 JEP（JDK Enhancement Proposals）来定义和管理纳入新版 JDK 发布范围的功能特性。JDK 8提供了那些曾在 JDK 7中规划过，但最终未能在 JDK 7中完成的功能，主要包括：</p><ul><li>JEP 126：对 Lambda 表达式的支持，这让 Java 语言拥有了流畅的函数式表达能力。</li><li>JEP 104：内置 Nashorn JavaScript 引擎的支持。</li><li>JEP 150：新的时间、日期 API。</li><li>JEP 122：彻底移除 HotSpot 的永久代。</li></ul><p>以上只是列出了JDK 8的部分新特性。</p><p><strong>JDK 9发布</strong></p><p>2017年9月21日，JDK 9发布。JDK 9主要发布了 Jigsaw（支持 Java 模块化，对标 OSGi），除了 Jigsaw 外，JDK 9还增强了若干工具（JS Shell、JLink、JHSDB 等），整顿了 HotSpot 各个模块各自为战的日志系统，支持 HTTP 2客户单 API 等91个 JEP。</p><p>JDK 9以后，Oracle 宣布每六个 JDK 大版本中才会被划出一个长期支持（Long Term Support，LTS）版，只有 LTS 版的 JDK 能够获得为期三年的支持和更新，普通版的 JDK 就只有短短六个月的生命周期。<strong>JDK 8和 JDK 11会是 LTS 版，再下一个就到2021年发布的 JDK 17了</strong>。</p><p><strong>JDK 10发布</strong></p><p>2018年3月20日，JDK 10如期发布，这版本的主要研发目标是内部重构，诸如统一源仓库、统一垃圾收集器接口、统一即时编译器接口（JVMCI 在 JDK 9已经有了，这里是引入新的 Graal 即时编译器）等，这些都将会是对未来 Java 发展大有裨益的改进，但对普通用户来说 JDK 10的新特性就显得乏善可陈，毕竟它只包含了12个 JEP，而且其中只有本地类型推断这一个编码端可见的改进。</p><p>JDK10以后，Oracle 选择把 J2EE“扫地出门”，所有权直接赠送给 Eclipse 基金会，唯一的条件是以后不准再使用“Java”这个商标，所以取而代之的将是 Jakarta EE。</p><p><strong>JDK 11发布</strong></p><p>2018年9月25日，JDK 11发布，这是一个 LTS 版本的 JDK，包含17个 JEP，其中有 ZGC 这样的革命性的垃圾收集器出现，也有把 JDK 10中的类型推断加入 Lambda 语法这种可见的改进。</p><p><strong>JDK 12发布</strong></p><p>2019年3月20日，JDK 12发布，只包含8个 JEP，其中主要有 Switch 表达式、Java 微测试套件（JMH）等新功能，最引人注目的特性无疑是加入了由 RedHat 领导开发的 Shen-andoah 垃圾收集器。</p><p>Shenandoah 作为首个由非 Oracle 开发的垃圾收集器，其目标又与 Oracle 在 JDK 11中发布的 ZGC 几乎完全一致，两者天生就存在竞争。Oracle 马上用实际行动抵制了这个新收集器，在 JDK 11发布时才说应尽可能保证 OracleJDK 和 OpenJDK 的兼容一致，转眼就在 OracleJDK 12里把 Shenandoah 的代码通过条件编译强行剔除掉，使其成为历史上唯一进入了 OpenJDK 发布清单，但在 OracleJDK 中无法使用的功能。</p><h2 id="Java-三条产品线">Java 三条产品线</h2><p>Sun 公司基于商业上的考量把 Java SDK 划分成 SE、ME、EE 三个版本。</p><p><img src="/img/java/SEMEEE.PNG" alt="Java 三条产品线之间的关系"></p><ul><li><strong>Java SE（J2SE，Java 2 Platform Standard Edition，标准版）</strong></li></ul><p>Java SE 之所以称之为“标准版”，涉及两个责任，一个责任是 Java SE 中的虚拟机、Java 语言、编译器、核心类库，它们是 Java ME、Java EE 的共同基础，对其起着支撑作用。</p><p>第二个责任是，即使不提对Java ME、Java EE的支持，Java SE本身也可以完成一些“标准”程序的开发，例如桌面程序，控制台程序等。</p><p>作为第一个责任，Java SE 的基础支撑作用当然无可争议，所以，在 Java SE 阶段的学习中，了解虚拟机原理，会使用编译器，掌握 Java 语法及核心类库是必须完成的。</p><p>但就 Java SE 的第二个责任来说，Java SE 则没有完成使命，主要原因是因为其在桌面开发市场上受到了微软的猛烈阻击。因为 Windows 在桌面市场上具有统治性的地位，而其拥有者微软又为开发者提供了一套从上到下、非常优秀的工具包（包括 C#、WPF、Visual Studio 等）。与之相比，Java SE 自带的 UI 框架（例如 AWT、Swing）则是显得如此的简陋和不堪。这也难怪，作为 Window 的拥有者，又有谁比微软更懂桌面开发的呢？</p><p>今天，就工业开发的现状来说，Java 在事实上已经退出了桌面开发市场了，与之相关的，Java SE 中与桌面相关的类库和框架也就失去了继续学习的意义。</p><p><img src="/img/java/jdk.webp" alt="Java SE JDK"></p><ul><li><strong>Java ME（J2ME，Java 2 Platform Micro Edition，微型版）</strong></li></ul><p>Java ME 承载了 Java 最初的在小设备上运行的使命。</p><p>考虑到小设备的资源有限，Java ME 对 Java SE 的虚拟机做了优化，裁减了一部分类库，重新设计了一部分类库。</p><p>在今天这个智能机时代，Java ME 早已退出了历史舞台，不见了踪影。据此，有人认为 Java ME 是个失败的产品。但我认为这种说法并不公平，因为它忽略了历史的具体过程。</p><p>在功能机时代，不像今天，有两个居于统治地位的操作系统（Android、IOS）成为事实上的标准。当时的各个手机厂商（著名的有诺基亚、摩托罗拉、三星等）不仅有形态各异的硬件，还有各自完全不兼容的操作系统。所以在当时，如果没有 Java ME 作为各个品牌的出厂标配，应用软件的兼容性绝对是所有开发者的梦魇。</p><p>而正是因为 Java ME 的存在，才使得那个时代的功能机有了一丝“智能”的味道。如果有从功能机时代一路过来的小伙伴，一定还记得，当时在“玩机”论坛发布、寻找、交换 Java ME 小游戏带给我们的快乐。</p><p>至于后来 Java ME 为什么没有更进一步，拥有今天 Android 和 IOS 的市场地位，这可能就是一个语言的宿命。就好像我们虽知道 C++有这样那样的缺点，但我们依然不会尝试把它改造成类似 Java 这样的托管语言。如果是那样做的话，那就不再是一个升级的 C++，而是一门全新的语言了。</p><p>但无论如何，今天，对 Java 学习者来说，是对 Java ME 说再见的时刻了。至于对 Java ME 的评价，我认为最公允的是：Java ME 终于在完成它的使命后，光荣的退出了历史舞台。</p><ul><li><strong>Java EE（J2EE，Java 2 Platform Enterprise Edition，企业版）</strong></li></ul><p>Java EE 的目标是用 Java 开发企业级软件。Java EE 由 SUN 牵头指定规范（标准），然后各大厂家根据规范具体实现。Oracle 公司将 Java EE 8 移交给了开源组织 Eclipse 基金会来进行管理，该平台改名为 Jakarta EE。</p><p><strong>Java EE 发展史</strong></p><table><thead><tr><th>版本</th><th>发布日期</th><th>焦点说明</th></tr></thead><tbody><tr><td>J2EE 1.4</td><td>2003.12</td><td><strong>对Web服务更好支持</strong>。启用javax命名空间。Servlet 2.4、JSP 2.0、EJB 2.1等</td></tr><tr><td>Java EE 5</td><td>2006.05</td><td>以Web为着力点继续优化。Servlet 2.5、JSP 2.1、<strong>EJB 3.0</strong>、注解支持等</td></tr><tr><td>Java EE 6</td><td>2009.12</td><td>添加了大量新技术来简化开发，如：<strong>Servlet 3.0</strong>(异步处理)、Bean Validation、EJB 3.1、JSF 2.0、JPA 2.0、<strong>上下文和依赖注入(CDI)</strong></td></tr><tr><td>Java EE 7</td><td>2013.06</td><td>提高生产力满足企业需求和HTML5。Servlet 3.1、<strong>WebSocket 1.0</strong>、JSON 1.0、JMX 2.0、Batch 1.0</td></tr><tr><td><strong>Java EE 8</strong></td><td>2017.08</td><td>增加了JSON绑定和安全相关。Servlet 4.0、Bean Validation 2.0、CDI 2.0、JPA 2.2</td></tr><tr><td><code>Jakarta EE入局</code></td><td><code>2017.08</code></td><td><code>Oracle将Java EE交给开源组织，Eclipse基金会接手（Apache基金会爆冷出局还是不想要？）。但Oracle不允许开源组织使用Java名号，所以Jakarta EE名称于2018.02.26应运而生</code></td></tr><tr><td><strong>Jakarta EE 8</strong></td><td>2019.09</td><td><strong>规范与 Java EE 8完全相同</strong>。Maven 的 GAV 变了：<code>javax.servlet:javax.servlet-api:4.0.1 -&gt; jakarta.servlet:jakarta.servlet-api:4.0.2</code>，但命名空间没变依旧还是 javax.*，算是个小过度吧</td></tr><tr><td>Jakarta EE 9</td><td>2020.11</td><td><strong>没有加入新功能</strong>，Eclipse 基金会的首个正式版本。命名空间从 <code>javax.*</code> 迁移到 <code>jakarta.*</code>，前者从此成为历史。<strong>所有模块</strong>大版本号+1，如 <code>Servlet 4.0.2 -&gt; Servlet 5</code> 以表示其断层式升级</td></tr><tr><td>Jakarta EE 9.1</td><td>2021.06</td><td>相较于9 <strong>没有</strong> 加入新API。主要提供对Java SE 11的运行支持</td></tr></tbody></table><h2 id="参考资料">参考资料</h2><p>[1] 《深入理解 Java 虚拟机》- 周志明<br>[2]  <a href="https://zhuanlan.zhihu.com/p/351843840">Java的前生今世（下） - 知乎</a><br>[3]  <a href="https://yourbatman.cn/x2y/3839cb84.html">从Java EE到Jakarta EE，企业版Java的发展历程 | YourBatman</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类型转换</title>
      <link href="/2023/04/14/type-casting/"/>
      <url>/2023/04/14/type-casting/</url>
      
        <content type="html"><![CDATA[<h2 id="强类型语言和弱类型语言">强类型语言和弱类型语言</h2><p>按照数据类型要求，编程语言可以分为强类型语言和弱类型语言。</p><ul><li>强类型语言是要求变量在使用之前必须声明数据类型，并且不能随意改变类型的语言，如 Java、C/C++、Golang 等。在编译时就进行类型检查，优点是可以提前发现类型错误，提高程序的效率和安全性，但缺点是需要显式声明变量的类型，增加了编程的复杂度和不灵活性。</li><li>弱类型语言是不要求变量声明数据类型，并且可以根据赋值改变类型的语言，如 Python、PHP、JavaScript 等。在运行时才进行类型检查，优点是不需要显式声明变量的类型，简化了编程的过程和提高了灵活性，但缺点是可能在运行时出现类型错误，降低了程序的效率和安全性。</li></ul><p>对于强类型语言，为了实现编程的灵活性，必然要涉及到类型转换。</p><h2 id="类型转换">类型转换</h2><p>Java 类型转换的原理可以分为以下几种情况：</p><ul><li><p>基本数据类型之间的转换，可以分为自动类型转换和强制类型转换。自动类型转换是从存储范围小的类型转换为存储范围大的类型，如 byte、short、char → int → long → float → double。强制类型转换是从存储范围大的类型转换为存储范围小的类型，如 double → float → long → int → byte、short、char。强制类型转换需要在等号后面的类型前加上强制()转换符，并且可能会造成数据精度的降低或溢出。基本数据类型之间的转换，是将一个数据类型的值的位模式解释为另一个数据类型的值的位模式。在这个过程中，java 使用的规则是将数据类型的值的位模式按照目标数据类型的格式进行解释和存储。如果目标数据类型的容量小于原数据类型的容量，那么可能会发生溢出或精度损失。如果目标数据类型的容量大于原数据类型的容量，那么可能会发生补位或扩展。</p></li><li><p>基本数据类型和 String 类型之间的转换，可以使用 String 类的静态方法 valueOf()或 toString()将基本数据类型转换为 String 类型，也可以使用基本数据类型对应的包装类的静态方法 parseInt()或 parseDouble()等将 String 类型转换为基本数据类型。</p></li><li><p>基本数据类型和对应的包装类型之间的转换，可以使用自动装箱和拆箱完成。自动装箱是将基本数据类型的值赋给对应的包装类对象，拆箱是将包装类对象赋给对应的基本数据类型变量。</p></li><li><p>引用数据类型之间的转换，可以分为向上转型和向下转型。在这个过程中，java使用的规则是检查两个引用类型之间是否存在继承关系，如果存在，那么可以进行向上转型或向下转型。 向上转型是将子类类型转换为父类类型，这是一种自动或隐式的转换。 向下转型是将父类类型转换为子类类型，这是一种强制或显式的转换。 在进行向下转型时，java会在运行时检查实际指向的对象是否是目标子类的实例，如果不是，那么会抛出ClassCastException异常。</p></li></ul><p>对于强类型语言，编译器在编译程序时会进行类型检查，防止出现类型转换的错误。</p><h2 id="多态">多态</h2><p>Java 多态是指当父类中的一个方法在不同的子类对象中被重载时，父类引用指向子类对象可以调用子类中重载的方法。</p><p>Java 多态的实现有三个必要条件：继承、重写和向上转型。</p><ul><li>继承：子类继承父类或实现接口，从而具有父类或接口中定义的方法。</li><li>重写：子类重写父类或接口中的方法，根据自己的特性提供不同的实现逻辑。</li><li>向上转型：父类或接口的引用变量指向子类的实例对象，从而可以调用子类重写的方法。</li></ul><p>Java 多态的实现机制是动态绑定，也就是在运行时根据引用变量所指向的具体实现对象来调用相应的方法，而不是引用变量的类型中定义的方法。</p><p>Java 多态的实现方式有三种：重载、接口和继承。</p><ul><li>重载：在同一个类中定义多个同名但参数不同的方法，根据传入参数的类型和个数来调用不同的方法。</li><li>接口：定义一个接口，包含一些抽象方法，让不同的类实现该接口，并重写其中的抽象方法，从而实现不同的行为。</li><li>继承：定义一个父类，包含一些普通或抽象方法，让不同的子类继承该父类，并重写其中的方法，从而实现不同的行为。</li></ul><h3 id="动态绑定">动态绑定</h3><p>动态绑定是一种调用对象方法的机制，它是指在运行时根据引用变量所指向的对象的实际类型来选择调用相应的方法，而不是引用变量的类型中定义的方法。</p><h4 id="C-动态绑定机制">C++ 动态绑定机制</h4><p>对于 C++来说，动态绑定的原理是利用虚函数表和虚函数指针来实现的。</p><ul><li>虚函数表：每一个定义了虚函数的类都会有一个虚函数表，它是一个存储虚函数入口地址的数组，每个虚函数占用一个数组元素。</li><li>虚函数指针：每一个定义了虚函数的类的对象都会有一个虚函数指针，它指向该对象所属类的虚函数表的首地址。</li></ul><p>动态绑定的过程如下：</p><ul><li>当使用基类或接口的引用变量调用虚函数时，编译器会根据引用变量的类型找到对应的虚函数表。</li><li>然后根据虚函数在虚函数表中的位置（偏移量）找到相应的虚函数入口地址。</li><li>最后通过虚函数指针调用该地址所指向的方法，这个方法可能是基类或派生类中重写或覆盖的方法，取决于引用变量所指向的对象的实际类型。</li></ul><p>动态绑定的好处是可以实现多态性，即同一个方法在不同的子类对象中有不同的实现方式，从而提高了代码的可扩展性和可维护性。</p><p>方法重载不会改变虚函数表的结构，只会增加虚函数表中的条目。虚函数表是一个存储虚函数入口地址的数组，每个虚函数占用一个数组元素。如果一个类中有多个重载的虚函数，那么它们都会被放入虚函数表中，按照声明顺序和参数类型来区分。</p><p>例如，如果有一个类 A，它有两个重载的虚函数 vfunc1 ()，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc1</span> <span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc1</span> <span class="params">(<span class="type">int</span>)</span></span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么它的虚函数表大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A_vtbl  --&gt;  A::vfunc1 () </span><br><span class="line">             A::vfunc1 (int)</span><br></pre></td></tr></table></figure><p>当使用基类或接口的引用变量调用虚函数时，编译器会根据引用变量的类型找到对应的虚函数表，然后根据虚函数在虚函数表中的位置（偏移量）找到相应的虚函数入口地址，最后通过虚函数指针调用该地址所指向的方法。<br>例如，如果有一个类 B 继承自类 A，并重写了 vfunc1 () 方法，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc1</span> <span class="params">()</span></span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么它的虚函数表大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B_vtbl  --&gt;  B::vfunc1 ()</span><br><span class="line">             A::vfunc1 (int)</span><br></pre></td></tr></table></figure><p>如果有一个基类指针 p 指向一个 B 类对象，那么当调用 p-&gt;vfunc1 () 时，编译器会先找到 B 类的虚函数表，然后在虚表中查找所调用的函数对应的条目。由于虚表在编译阶段就可以构造出来了，所以可以根据所调用的函数定位到虚表中的对应条目。对于 p-&gt;vfunc1 () 的调用，B vtbl 的第一项即是 vfunc1 () 对应的条目。</p><p>最后，根据虚表中找到的函数指针，调用函数。在这个例子中，就是调用 B 类重写的 vfunc1 () 方法。</p><p>子类的虚函数表与父类的虚函数表有以下不同点：</p><ul><li>子类和父类不会公用一个虚函数表，每个类都会有一个虚函数表。</li><li>子类的虚函数表会继承父类的虚函数表中的指针，如果子类没有重写父类的虚函数，那么子类虚函数表中仍然会有该函数的地址，只不过这个地址指向的是父类的虚函数实现。</li><li>子类的虚函数表中如果重写了父类的虚函数，那么子类虚函数表中对应的指针会被修改为指向子类的虚函数实现。</li><li>子类的虚函数表中如果新增了虚函数，那么子类虚函数表中会增加新的指针，指向子类新增的虚函数实现，并且按照声明顺序存放在父类虚函数表指针之后。</li></ul><h4 id="Java-动态绑定机制">Java 动态绑定机制</h4><p>Java 动态绑定的机制是指当调用对象方法时，该方法会和该对象的内存地址或运行类型绑定，而不是和对象变量的声明类型绑定。Java 动态绑定的机制和 C++有一些相似之处，也有一些不同之处。相似之处在于：</p><ul><li>两种语言都是通过虚函数表和虚函数指针来实现动态绑定的，即在运行时根据对象的实际类型来调用相应的虚函数。</li><li>两种语言都是只有虚函数才能实现动态绑定，而非虚函数则是静态绑定，即在编译时就确定调用哪个函数。</li><li>两种语言都需要通过基类指针或引用来调用子类对象的虚函数，才能体现出多态性。</li></ul><p>不同之处在于：</p><ul><li>Java 中所有的非静态方法都是默认为虚函数的，而 C++中需要用 virtual 关键字来显式声明虚函数。</li><li>Java 中对象的属性没有动态绑定机制，即总是访问对象变量的声明类型所定义的属性，而不是对象的实际类型所定义的属性。而 C++中对象的属性也可以实现动态绑定，只要将属性声明为虚函数，并在子类中重写该虚函数。</li><li>Java 中没有多重继承，只有单一继承和接口实现，因此不存在菱形继承问题，也不需要虚基类表来解决共享基类问题。而 C++中有多重继承，因此需要处理菱形继承问题，并使用虚基类表来记录虚基类子对象相对于虚基类表指针的偏移量。</li></ul><p>因此，java 动态绑定的机制和 C++动态绑定的机制在原理上是类似的，但在具体实现上有一些差异，主要体现在虚函数的声明、属性的访问和多重继承方面。</p><p>对于 Java 的多态来说，当把子类对象赋值给父类对象时，引用的地址并没有发生改变，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Example fun1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Example fun2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example1</span> <span class="keyword">extends</span> <span class="title class_">Example</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Example1 fun1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Example1 fun3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Example</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Example1</span>();</span><br><span class="line">        <span class="type">Example1</span> <span class="variable">e1</span> <span class="operator">=</span> (Example1)e;</span><br><span class="line">        e.fun1();</span><br><span class="line">        System.out.println(e);          <span class="comment">// Example1@15db9742</span></span><br><span class="line">        System.out.println(e1);         <span class="comment">// Example1@15db9742</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上述程序，当我们调用 e.fun3() 时，会编译不通过，并不是说将 Example1 的实例赋值给 e 时，e 所指向的地址块中不包含 fun3() 的代码，只是编译器在执行类型检查时不允许我们这么做。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 评论系统</title>
      <link href="/2023/04/09/hexo-comment/"/>
      <url>/2023/04/09/hexo-comment/</url>
      
        <content type="html"><![CDATA[<h1>Hexo 评论系统</h1><p>上一篇文章<a href="https://fhhw.github.io/2022/10/22/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/index.html">博客搭建教程</a>搭建了一个博客的基本框架，但是没有解决博客评论问题，本文填充一下这部分欠缺。</p><p>Hexo 博客系统是静态博客，本身无法支持评论等动态的功能，但是可以通过第三方的评论系统让 Hexo 博客支持评论功能。常见的评论系统包括：Valine、Disqus、Gitment、Giscus 等，本文主要介绍 Giscus 的使用。</p><h2 id="giscus-简介">giscus 简介</h2><p>giscus是由 <a href="https://docs.github.com/en/discussions">GitHub Discussions</a> 驱动的评论系统。让访客借助 GitHub 在你的网站上留下评论和反应，该项目受 <a href="https://github.com/utterance/utterances">utterances</a> 启发。包括以下特性：</p><ul><li>开源；</li><li>无跟踪，无广告，永久免费；</li><li>无需数据库，全部数据均储存在 GitHub Discussions 中；</li><li>支持自定义主题；</li><li>支持多种语言；</li><li>高度可配置；</li><li>自动从 GitHub 拉取新评论与编辑；</li><li>可自建服务；</li></ul><h3 id="运作原理">运作原理</h3><p>giscus 加载时，会使用 <a href="https://docs.github.com/en/graphql/guides/using-the-graphql-api-for-discussions#search">GitHub Discussions 搜索 API</a> 根据选定的映射方式（如 URL、<code>pathname</code>、<code>&lt;title&gt;</code> 等）来查找与当前页面关联的 discussion。如果找不到匹配的 discussion，giscus bot 就会在第一次有人留下评论或回应时自动创建一个 discussion。</p><p>要评论，访客必须按 GitHub OAuth 流程授权 <a href="https://github.com/apps/giscus">giscus app</a> <a href="https://docs.github.com/en/developers/apps/identifying-and-authorizing-users-for-github-apps">代表他发帖</a>。或者访客也可以直接在 GitHub Discussion 里评论。你可以在 GitHub 上管理评论。</p><h2 id="在-Hexo-中配置-giscus">在 Hexo 中配置 giscus</h2><p>**Step 1：**新建 Github 仓库，确保：</p><ol><li>此仓库是<a href="https://docs.github.com/en/github/administering-a-repository/managing-repository-settings/setting-repository-visibility#making-a-repository-public">公开的</a>，否则访客将无法查看 discussion。</li><li><a href="https://github.com/apps/giscus">giscus</a> app 已安装否则访客将无法评论和回应。</li><li>Discussions功能已<a href="https://docs.github.com/en/github/administering-a-repository/managing-repository-settings/enabling-or-disabling-github-discussions-for-a-repository">在你的仓库中启用</a>。</li></ol><p>**Step 2：**Hexo 配置</p><p>在你的 Hexo 博客目录中执行以下命令，安装 hexo-next-giscus 插件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-next-giscus --save</span><br></pre></td></tr></table></figure><p>然后在 Hexo 的 _config.yml 配置文件添加如下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">giscus:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="comment"># Github repository name</span></span><br><span class="line">  <span class="attr">repo_id:</span> <span class="comment"># Github repository id</span></span><br><span class="line">  <span class="attr">category:</span> <span class="comment"># Github discussion category</span></span><br><span class="line">  <span class="attr">category_id:</span> <span class="comment"># Github discussion category id</span></span><br><span class="line">  <span class="comment"># Available values: pathname | url | title | og:title</span></span><br><span class="line">  <span class="attr">mapping:</span> <span class="string">pathname</span></span><br><span class="line">  <span class="comment"># Available values: 0 | 1 </span></span><br><span class="line">  <span class="attr">reactions_enabled:</span> <span class="number">1</span></span><br><span class="line">   <span class="comment"># Available values: 0 | 1 </span></span><br><span class="line">  <span class="attr">emit_metadata:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Available values: light | dark | dark_high_contrast | transparent_dark | preferred-color-scheme</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">light</span></span><br><span class="line">  <span class="comment"># Available values: en | zh-C</span></span><br><span class="line">  <span class="attr">lang:</span> <span class="string">en</span></span><br><span class="line">  <span class="comment"># Available value: anonymous</span></span><br><span class="line">  <span class="attr">crossorigin:</span> <span class="string">anonymous</span></span><br></pre></td></tr></table></figure><p>或者在主题的配置文件 _config.themename.yml 中对应项添加即可，例如 butterfly 主题：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">giscus:</span></span><br><span class="line"> <span class="attr">repo:</span>    <span class="comment"># uername/repo_name</span></span><br><span class="line"> <span class="attr">repo_id:</span> </span><br><span class="line"> <span class="attr">category_id:</span> </span><br><span class="line"> <span class="attr">theme:</span></span><br><span class="line">  <span class="attr">light:</span> <span class="string">light</span></span><br><span class="line">  <span class="attr">dark:</span> <span class="string">dark</span></span><br><span class="line"> <span class="attr">option:</span></span><br></pre></td></tr></table></figure><p><code>repo_id</code>是托管博客的代码仓库的一个标识值，<code>category</code>是该仓库Issues里面对应的分类（或者说是主题）。一个仓库默认具有下面几个分类：Announcements、General、Ideas、Q&amp;A、Show and tell。这里我选择General作为评论的分类。最后的<code>category_id</code>类似<code>repo_id</code>也是对该分类的一个标识值。</p><p>如何快速的获取这些数据呢，可以通过GitHub官方的<a href="https://docs.github.com/en/graphql/overview/explorer">GraphQL API Explorer</a>查询到。这里把查询所用的语句进行记录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  repository (name: &quot;repo_name&quot;, owner: &quot;owner_name&quot;)  &#123;</span><br><span class="line">    id</span><br><span class="line">    discussionCategories (first: 5) &#123;</span><br><span class="line">      nodes &#123;</span><br><span class="line">        name</span><br><span class="line">        id</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将查询数据填入对应项即可。</p><p>推荐使用**公告（announcements）**类型的分类，以确保新 discussion 只能由仓库维护者和 giscus 创建。</p><h2 id="参考资料">参考资料</h2><p>[1] <a href="https://giscus.app/zh-CN">Giscus</a></p><p>[2] <a href="https://www.michaeltan.org/posts/giscus/">Giscus的基础设置</a></p><p>[3] <a href="https://stackoverflow.com/questions/13902593/how-does-one-find-out-ones-own-repo-id">How does one find out one’s own Repo ID?</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go module 与 package</title>
      <link href="/2023/03/24/go-module-package/"/>
      <url>/2023/03/24/go-module-package/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>笔者在学习 golang 语言的时候，对其版本管理产生了诸多困惑，于是花费了几天时间搜集了很多资料，试图理解其背后的原理，现将搜集的资料整理成下文。建议大家在理解这一部分的时候去看看 Go 团队的 leader Russ Cox 的解释：[Go &amp; Versioning]([ <a href="https://research.swtch.com/vgo">https://research.swtch.com/vgo</a> )，其中文翻译网址为：<a href="https://github.com/vikyd/note/tree/master/go_and_versioning">note/go_and_versioning at master · vikyd/note · GitHub</a></p><h1>正文</h1><p>软件是由代码组成的。为了复用代码，代码的组织出现了不同层次的抽象和实现，如 Module（模块），包（Package），Lib（库），Framwork（框架）等。</p><h2 id="package">package</h2><p>Golang 使用包（package）这种语法元素来组织源码，所有语法可见性均定义在 package 这个级别，与 Java 、python 等语言相比，这算不上什么创新，但与 C 传统的 include 相比，则是显得“先进”了许多。</p><p>C 语言中所有未加 static 前缀的全局变量和函数都具有全局可见性；Java、C++则通过 public/private 关键字来定义可见性；在 Go 语言中，没有特别的关键字来声明一个方法、函数或者类型是否为公开的，Go 语言是以大小写方式进行区分的，如果一个类型的名字是以大写开头，那么其他包就可以访问；如果以小写开头，其他包就不能访问。</p><p>go 语言中一个文件夹即为一个包 (package)，也就是说一个文件夹下的同级源代码文件必须声明成一个包，这些同级源代码文件相当于一个文件，拆分成不同文件，一方面体现了 go 小而简洁的哲学，另一方面便于阅读和维护。允许文件夹名与包名不同，根据惯例，建议文件夹名与包名相同。注意：</p><ul><li>import 后面的是目录（即包的路径），一般为项目名 + 路径；</li><li>包名和目录名没有关系，但是包名最好等于目录名；</li><li>同一个目录下只能有一种包名；</li><li>一个包可以内嵌子包。</li></ul><h3 id="main-package">main package</h3><p>一个 go 模块要编译成可执行二进制文件，必须有包含 main 函数的 main 包。不像解释性语言，go 模块可以编译成一个不需要任何依赖就可以执行的二进制文件。</p><h2 id="go-module">go module</h2><h3 id="依赖管理">依赖管理</h3><p>我们想复用已有的工作成果，将已有的工作成果加入到我们的项目中作为依赖存在着太多的不确定性：这个包的 API 会变化；这个包内部行为会变化；这个包的依赖会变化；这个包可能已经已经不存在或无法访问；包与包之间的不同依赖相互冲突等等。不仅如此，随着软件开发规模的逐步增大，涉及到的外部依赖越来越多，手动管理的所有依赖愈发不可能。所以我们需要依赖管理，我们需要有个工具或者规范来描述和定义包与包之间的依赖关系，并自动化的去处理、解析和满足这些依赖。</p><p>依赖管理试图解决的问题主要有两个：<br>其一是 <code>API 稳定性</code>，不会因为我们更新了一个小版本就要大规模的重写我们的代码。<br>其二是<code>可重现构建</code>，可重现构建在我们依赖管理的领域内可以理解为相同的源码最后能得到同样的二进制或链接库（当然真正的想实现可重现构建还需要一系列配套的工具和特定的参数）。</p><h3 id="早期-GOPATH">早期 GOPATH</h3><p>在 go1.12 之前，安装 golang 之后，需要配置两个环境变量 <code>$GOROOT</code> 和 <code>$GOPATH</code>。前者是 go 安装后的所在的路径，后者是开发中自己配置的，用于存放 go 源代码的地方。在 GOPATH 路径内，有三个文件夹，分别是：</p><ul><li>bin: go 编译后的可执行文件所在的文件夹</li><li>pkg: 编译非 main 包的中间连接文件</li><li>src: 存放项目的源代码，可以是你自己写的代码，也可以是你 go get 下载的包</li></ul><p>$GOPATH 即为我们的工作目录，所有的项目源代码都放在 $GOPATH 路径下的 src 目录中。在这个模式下，使用 go install 时，生成的可执行文件会放在 <code>$GOPATH/bin</code> 下，如果你安装的是一个库，则会生成 .a 文件到 <code>$GOPATH/pkg</code> 下对应的平台目录中（由目标操作系统 <code>GOOS</code> 和目标架构 <code>GOARCH</code> 组合而成），生成 .a 为后缀的文件。</p><p>早期的这种模式源于 Google 的开发方式，Google 本身就有一个中央集中式中心用来管理软件包，使用，构建都从那里获取，因为外人无法访问 google 的中央，但是这种引用中央的开发模式被保留下来，因此就抽象成本地的 GOPATH。</p><p>使用这种模式会产生很多问题，最主要的是版本管理问题：</p><ul><li>你无法在你的项目中，使用指定版本的包，因为不同版本的包的导入方法也都一样</li><li>其他人运行你的开发的程序时，无法保证他下载的包版本是你所期望的版本，当对方使用了其他版本，有可能导致程序无法正常运行</li><li>在本地，一个包只能保留一个版本，意味着你在本地开发的所有项目，都得用同一个版本的包，这几乎是不可能的。</li></ul><h3 id="早期解决方案">早期解决方案</h3><p><img src="/img/golang/go_dep_management.png" alt="go 依赖管理"><br>Go 语言的依赖管理经历了漫长的迭代和演进，最终随着 <a href="https://golang.org/ref/mod">Go Modules</a> 被官方采纳，形成大一统局面。</p><h5 id="Go-依赖管理的演进历史">Go 依赖管理的演进历史</h5><p><strong>阶段一：Makefile、goinstall、go get</strong><br>早在2009年11月，Go 最初版本的发布只包括：编译器、连接器和一些基本的库。此时 Go 程序需要自己运行 <code>6g</code> 和 <code>6l</code> 完成编译过程，因此官方发布的程序中也附加了一些 Makefile 的示例。</p><p>2010年2月，官方引入 goinstall（注意：这里的 goinstall 和 go 命令中的 go install 不是同一个概念）。这是一个零配置的命令，从代码仓库中直接下载包。goinstall 在当时引入了现在开发者已经非常熟悉的包导入规则，后面逐步形成明朗的生态系统。goinstall 终结了 Makefile 中五花八门实现造成的复杂性，这种化简对于形成统一工具链也具有极大正面作用。</p><p>2011年12月，go get 代替 goinstall 进入 go 命令，并成为 Go 官方支持的工具链。总体而言，go get 相比于 C/C++ 的依赖管理来说有革命性进步：</p><ol><li>允许 Go 的开发者方便地共享代码，和依赖他人的包进行构建。</li><li>将构建系统的细节隔离在 go 命令中。</li></ol><p>但 go get 缺少版本管理功能，当 go get 请求一个包的时候，它总是拉取最新的代码，并将拉取动作交给 Git、Mercurial 等版本管理系统去做。go get 对于版本管理的缺少至少带来两个致命问题。</p><p><strong>阶段二：语义版本和 API 稳定性</strong><br>go get 的第一个致命问题：由于没有版本的概念，在包更新时候它不知道该以什么方式通知用户（兼容性的还是非兼容性的）。</p><p>2013年11月，Go 1.2 的 FAQ 中增加了一条关于包版本管理的基本建议（此建议直到 Go 1.10 都没变过）：</p><blockquote><p>发布到公共使用的包，在演进时应尽量保持向后兼容性（如 v1.5 应兼容 v1.4）。<a href="https://golang.org/doc/go1compat.html">Go 1 的兼容性指南</a>就是一个很好的参考：不要移除已暴露的命名，鼓励使用组合单词来命名，等等。若需不同的功能，请创建一个新的命名，而非直接修改旧名字下的功能。若必须引入不兼容的修改，请创建一个新的包，并使用新的 <code>import</code> 路径。</p></blockquote><p>2014年3月，Gustavo Niemeyer 创建了 <a href="https://gopkg.in/">gopkg.in</a>，倡议在 Go 语言中编写稳定的 API。此网站可从 <code>go get</code> 的 URL 中解释出包的版本，并转发 GitHub 中对应版本的源码，如 <code>gopkg.in/yaml.v1</code>、<code>gopkg.in/yaml.v2</code> 分别对应 Git 仓库中的不同提交（也可能刚好是不同的分支）。基于语义的版本管理（semver），gopkg 希望包作者在引入不兼容性修改时创建一个新的主版本号，由于 <code>v2</code> 是完全不同的 API，所以 <code>v2</code> 的 <code>import</code> 路径可逐步替换 <code>v1</code> 的 <code>import</code> 路径（注：因为二者可被同时使用）。</p><p><strong>阶段三：Vendor 模式和可复现构建</strong><br>go get 的第二个致命问题：它无法保证构建是稳定可复现的，这意味着包的开发者和包的使用者很容易出现依赖不同版本的情况。</p><p>2013 年 11 月，Go 1.2的 FAQ 中还添加了这条基本建议：</p><blockquote><p>使用一个外部的依赖包时，你若担心该包无故发生变化，最简单粗暴的解决办法是复制一份到你的本地仓库（Google 内部也是使用这种方法）。将副本存储在一个新的 <code>import</code> 路径中，将其标识为本地副本。例如，你可将 <code>original.com/pkg</code> 复制为 <code>you.com/external/original.com/pkg</code>。Keith Rarick 写了一个名为 <code>goven</code> 的工具将此过程自动化。</p></blockquote><p>在这个阶段，各种第三方的 Go 依赖管理工具已经开始出现。它们都基于复制依赖的原理，通过非官方 Hack 的方式来完成可复现构建。</p><p>因此，Go 官方在看到这个乱象之后，正式推出官方 vendor 机制。vendor 目录用于存放依赖包，加载顺序是：vendor &gt; GOROOT &gt; GOPATH。vendor 于 Go 1.5进入实验阶段，于 Go 1.6 成为默认启动的功能。</p><p>从本质上说，vendor 机制只是包管理的一种不完整解决方案。它只提供了稳定可复现构建的能力，但并没有告诉项目具体用哪个版本。于是类似 glide、godep、govendor 等第三方包管理工具，通过添加特殊的版本信息记录文件，来做隐式包版本管理。但由于 Go 的官方工具链都无法识别类似的文件，因此导致 Go 工具链生态与之割裂。</p><p><strong>阶段四：官方包管理器实验</strong><br>在 GopherCon 2016 会议之后，Go 成立了一个包依赖管理器委员会和一个讨论小组，目的是创造一个新的依赖管理工具 <a href="https://github.com/golang/dep">dep</a>。这个工具的愿景是统一目前各种 Go 的包管理器，继续使用 vendor 目录，但依然不属于 Go 官方工具链的原生功能。</p><p>引用 Russ Cox 在博客中所说：</p><blockquote><p>dep 有几大作用：</p><ul><li>它是今天为止可用的工具实践中的重要进步</li><li>它是朝一个解决方案前进的重要一步</li><li>它也是“官方实验”，试验哪些功能对 Go 开发者有用或没用</li></ul><p>但 dep 不是 go 命令中整合版本管理的直接原型。dep 是一个强大的、很灵活的工具，探索了包管理的设计空间，在我们争论着如何对 Go 程序进行构建时，扮演着类似 Makefile 的角色。但当我们对包管理的设计空间了解得更深、明白到哪些关键特性必须实现后，我们才知道如何在 Go 生态系统中移除那些不必要的功能、灵活性。然后采取强制的约定，使得 Go 的代码库更统一、更易于理解、相关工具更易于构建。</p></blockquote><p><strong>阶段五：vgo 提案和最终的官方解决方案 Go Modules</strong><br>dep 终究没有被官方采纳，虽然 Russ Cox 肯定了 dep 的历史作用，但 dep 本质上仍是 vendor 机制下的延伸，并且 dep 坚持语义版本，而并未使用 Go Modules 方案中的语义导入版本。因此，vgo 提案正式提出。</p><p>vgo 由 Russ Cox 于 2018 年提出，它建议采用语义导入版本规则结合最小版本选择规则。另一方面，vgo 希望能够与 Go 官方工具链相结合，因此最初以 “vgo” 命名，并且实验性阶段以替代 go 命令的方式运行。</p><p>vgo 很快得到官方认可，并作为正式 proposal 开发合入主干，最终以 go mod 命令正式纳入官方工具链。</p><p>Go Modules 去除 GOPATH 和 vendor 目录的依赖，不再需要基于复制依赖的做法，大大减少源码包的体积并杜绝了修改 vendor 目录内容的行为。另一方面，Go Modules 还集成进了 go 命令中，配合 go get、go list、go build 等等命令协同工作，整体体验更加优秀。</p><p>至此，Go 结束了漫长的依赖管理之争，最终形成大一统局面。但另一方面，vgo 的发布引发了社区的强烈动荡，以 dep 为首的开发者为此感到沮丧 <a href="https://www.kevinwu0904.top/blogs/golang-modules/#fn:1">1</a>。</p><h3 id="Go-Modules">Go Modules</h3><p><strong>语义版本 vs 语义导入版本</strong><br><strong>语义版本</strong>（semantic versioning）是指在 Go 语言中对同一个依赖的不同兼容性版本使用统一的 import 名称，即相同的 import 路径，在辅助文件中记录版本信息。语义版本的代表是 dep，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/robfig/cron&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Gopkg.toml 版本1.2.0</span></span><br><span class="line"><span class="section">[[constraint]]</span></span><br><span class="line">  <span class="attr">name</span> = <span class="string">&quot;github.com/robfig/cron&quot;</span></span><br><span class="line">  <span class="attr">version</span> = <span class="string">&quot;1.2.0&quot;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Gopkg.toml 版本3.0.1</span></span><br><span class="line"><span class="section">[[constraint]]</span></span><br><span class="line">  <span class="attr">name</span> = <span class="string">&quot;github.com/robfig/cron&quot;</span></span><br><span class="line">  <span class="attr">version</span> = <span class="string">&quot;3.0.1&quot;</span></span><br></pre></td></tr></table></figure><p><strong>语义导入版本</strong>（semantic import versioning）则是指在 Go 语言中对同一个依赖的不同兼容性版本使用不同的 import 名称，即不同的 import 路径，同时也在辅助文件中记录版本信息。导入版本的代表是 go module，例如：</p><ul><li>v1大版本</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/robfig/cron&quot;</span> <span class="comment">// v1大版本</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go.mod</span></span><br><span class="line">require (</span><br><span class="line">github.com/robfig/cron v1<span class="number">.2</span><span class="number">.0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>v3大版本</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/robfig/cron/v3&quot;</span> <span class="comment">// v3大版本</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go.mod</span></span><br><span class="line">require (</span><br><span class="line">github.com/robfig/cron v3<span class="number">.0</span><span class="number">.1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>import兼容性规则</strong><br>Go语言的import兼容性规则是指：</p><blockquote><p>如果一个旧包与新包共用相同的 import 路径，那么新包必须向后兼容旧包。</p></blockquote><p>Go的开发者采用业界通用的semantic versioning作为版本标识符，它形如（vmajor.minor.patch）：<br><img src="/img/golang/semver.png" alt="semver"></p><ul><li>Major version：主版本，通常是大版本升级，导致向前不兼容</li><li>Minor version：次版本，通常是向下兼容的 feture</li><li>Patch version：修订版本，如一些 bugfix</li></ul><p>Go 的兼容性规则希望开发者遵守如下守则：</p><ol><li>相同大版本，新包需要完全兼容旧包（通过诸如不删除弃用方法，不修改导出变量等手段）。例如：v1.3.1需要完全兼容v1.2.0。</li><li>不同大版本，允许存在不兼容改动。例如：v3.0.0和v1.0.0允许声明不兼容的接口方法。</li><li>v0.0.0到v1.0.0之间由于处于开发阶段，允许存在大量不兼容的行为，但需要开发者自己处理。</li></ol><p><strong>最小版本选择（MVS）</strong><br><a href="https://research.swtch.com/vgo-mvs"><strong>Minimal Version Selection</strong></a> 是 go mod 所实现的关于依赖升级和降级的选择策略。它的工作方式是这样的：我们为每个模块指定的依赖都是可用于构建的最低版本，最后实际选择的版本是所有出现过的最低版本中的最大值。</p><p>我们现在有这样的一个依赖关系，A 会依赖 B，C，而 B，C 会去依赖 D，D 又会依赖 E：<br><img src="/img/golang/mvs-1.png" alt="mvs"><br>把每个模块依赖的版本都找出来，这样我们会首先得到一个粗略的清单。然后相同的模块我们总是取最大的版本，这样就能得到最终的依赖列表：<br><img src="/img/golang/version-select-list.png" alt="version-select-list"><br>go mod 中使用的算法有 BuildList、Req、Upgrade、Downgrade 等。</p><p><strong>go.mod 和 go.sum</strong><br>go mod 在工程中引入 go.mod 和 go.sum 文件，其中 go.mod 文件用于记录依赖的版本信息，go.sum 文件用来记录依赖的 hash 值。</p><p>go.mod 文件示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module example.com/my/thing</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.12</span></span><br><span class="line"></span><br><span class="line">require example.com/other/thing v1<span class="number">.0</span><span class="number">.2</span></span><br><span class="line">require example.com/<span class="built_in">new</span>/thing/v2 v2<span class="number">.3</span><span class="number">.4</span></span><br><span class="line">exclude example.com/old/thing v1<span class="number">.2</span><span class="number">.3</span></span><br><span class="line">replace example.com/bad/thing v1<span class="number">.4</span><span class="number">.5</span> =&gt; example.com/good/thing v1<span class="number">.4</span><span class="number">.5</span></span><br><span class="line">retract [v1<span class="number">.9</span><span class="number">.0</span>, v1<span class="number">.9</span><span class="number">.5</span>]</span><br></pre></td></tr></table></figure><ul><li>require：require 记录的内容也即根据 MVS 中算法二：Req 生成的列表</li><li>exclude：exclude 可以记录一个版本的黑名单，防止该版本被引用</li><li>replace：replace 可以用于替换一个依赖</li><li>retract：go1.16 新特性，可以用于包的开发者紧急撤回某个已知 BUG 的版本</li></ul><p>go.sum 考虑的是依赖防篡改的问题。第一次拉取包含 go.sum 的工程，项目运行之后通常会去拉取依赖包。此时会通过 sha256（内容摘要算法）计算依赖包的 hash 值，并与 go.sum 记录值进行比较。go.sum 期望行为是 Append-Only 配合工具生成。</p><p><strong>命令行与工作流</strong><br>go mod 目前也是 Go 官方工具链中的一员，go mod 的常用工作流大致如下：</p><ol><li>创建新的 module：<code>go mod init</code> 首次接入 go mod 的项目可以通过 init 命令完成，init 命令会解析项目源码中 go 文件的 import 信息，并根据 MVS 相关算法，计算出相关依赖并最终生成 go.mod 和 go.sum。</li><li>列出当前 module 下的所有依赖：<code>go list -m -json all</code></li><li>升级/降级一个依赖到指定版本：<code>go get -u github.com/pkg/errors@v0.9.0</code></li><li>升级所有依赖：<code>go get -u all</code></li><li>下载依赖包：<code>go mod download</code></li><li>下载依赖包并且精简 mod 和 sum 的内容：<code>go mod tidy</code></li></ol><p>go1.12 默认开启 go Module 功能，go1.12 会在用户的 $home 目录下创建一个 go 文件夹作为默认的 GOPATH。go get 会将远程的软件包 download 在 $home/go/pkg/mod 目录里。</p><p>以上为本文整理的全部资料，其中大部分内容来自于 <a href="https://www.kevinwu0904.top/blogs/golang-modules/">深入解析Go Modules | 极客熊生</a>，讲解清晰，推荐大家看看。</p><h2 id="参考资料">参考资料</h2><p>[1]  <a href="https://www.jianshu.com/p/07ffc5827b26">Golang Package 与 Module 简介</a><br>[2]  <a href="https://www.cnblogs.com/maji233/p/11045166.html">理解Golang包导入，import、包名、目录名的关系</a><br>[3]  <a href="https://xuanwo.io/2019/05/27/go-modules/">Go Modules 内部分享</a><br>[4]  <a href="https://www.cnblogs.com/wongbingming/p/12941021.html">一文搞懂 Go Modules 前世今生及入门使用</a><br>[5]  <a href="https://www.kevinwu0904.top/blogs/golang-modules/">深入解析Go Modules | 极客熊生</a></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跳表 skiplist 简介</title>
      <link href="/2023/03/16/skiplist/"/>
      <url>/2023/03/16/skiplist/</url>
      
        <content type="html"><![CDATA[<h2 id="跳表-skiplist">跳表 skiplist</h2><p>跳表 (Skip List) 是由 William Pugh 在 1990 年发表的文章 Skip Lists: A Probabilistic Alternative toBalanced Trees 中描述的一种查找数据结构，支持对数据的快速查找，插入和删除。</p><p>对于 AVL 树、红黑树等平衡树，在插入过程中需要做多次旋转操作，实现复杂，而跳表实现更简单、开销更低，应用广泛。</p><p><img src="/img/algorithm/skip_list.png" alt="skip list"></p><p>跳表是一个包含随机算法的数据结构，跳表的查找、插入、删除的==平均时间复杂度==都是<font color="#2DC26B"> O(logn)</font>，而且可以按照范围区间查找元素，==空间复杂度==是 <font color="#00b050">O(n)</font>。</p><p>跳表的最底层通常是一个==有序链表==，上层是下层的一个==索引==，下层元素出现在上层的概率为 p (通常 p=1/2)。</p><h3 id="跳表的创建过程">跳表的创建过程</h3><p>首先，对于一个有序链表，如果我们需要查找元素，则需要从头开始遍历链表，查找时间复杂度为 O(n)。如果我们每相邻两个节点增加一个指针，让指针指向下下个节点，那么上层形成了一个减缩版的链表，当我查找元素时，先在上层链表查找，当待查元素在两个节点之间时，再回到下层链表查找，这样我们就可以跳过一些节点，提高查找速度。以此类推，我们可以在第二层链表上建立第三层链表……查找一个元素时，从最高层开始，逐层向下，直到找到为止。</p><p><img src="/img/algorithm/linklist.png" alt="linklist"></p><p>上述我们建立的数据结构就是一个跳表，我们可以将上层链表看作是下层链表的一个索引，每相邻两个、三个……建立一个索引，这是一种确定性策略，如果只是查找操作，这么建立跳表没有问题。但是当我们需要频繁插入和删除元素时，这种确定性策略会使维护跳表变得复杂。</p><p>为了解决上述问题，我们引入随机策略，不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是为每个节点随机产生一个层数(level)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该 randomLevel 方法会随机生成 1~MAX_LEVEL 之间的数，且 ：</span></span><br><span class="line"><span class="comment">//        1/2 的概率返回 1</span></span><br><span class="line"><span class="comment">//        1/4 的概率返回 2</span></span><br><span class="line"><span class="comment">//        1/8 的概率返回 3 以此类推</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="type">int</span> <span class="title">randomLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> level = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 当 level &lt; MAX_LEVEL，且随机数小于设定的晋升概率时，level + 1</span></span><br><span class="line">  <span class="keyword">while</span> (Math.<span class="built_in">random</span>() &lt; SKIPLIST_P &amp;&amp; level &lt; MAX_LEVEL)</span><br><span class="line">    level += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建跳表我们首先需要一个返回层数的随机函数 randomlevel()，在有序链表的每一个元素上运行该随机函数，当返回 level=1 时，不创建索引；当返回 level=2 时，对该元素创建一级索引；当返回 level=3 时，对该元素创建一级和二级索引……</p><p>如果 SKIPLIST_P=1/2 时，一级索引有 n/2 个元素，二级索引有 n/4 个元素……空间复杂度为 O(n)。如果底层链表中的元素存储的是对象，索引只需存储对象排序的键值 key 即可。</p><h3 id="查找元素">查找元素</h3><p><img src="/img/algorithm/skip_list_search.png" alt=""></p><p>查找元素时，从最高层索引开始查找，逐层向下，直到找到为止。根据概率可以证明查找的平均时间复杂度为 O(logn)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V&amp; <span class="title">find</span><span class="params">(<span class="type">const</span> K&amp; key)</span> </span>&#123;</span><br><span class="line">  SkipListNode&lt;K, V&gt;* p = head;</span><br><span class="line">  <span class="comment">// 找到该层最后一个键值小于 key 的节点，然后走向下一层</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = level; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;forward[i]-&gt;key &lt; key) &#123;</span><br><span class="line">      p = p-&gt;forward[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 现在是小于，所以还需要再往后走一步</span></span><br><span class="line">  p = p-&gt;forward[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// 成功找到节点</span></span><br><span class="line">  <span class="keyword">if</span> (p-&gt;key == key) <span class="keyword">return</span> p-&gt;value;</span><br><span class="line">  <span class="comment">// 节点不存在，返回 INVALID</span></span><br><span class="line">  <span class="keyword">return</span> tail-&gt;value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入元素">插入元素</h3><p><img src="/img/algorithm/Skip_list_add_element-en.png" alt=""></p><p>插入元素的关键是查找元素的合适插入位置，将元素插入链表中之后，运行 randomlevel 函数，确定在该元素上建立几层索引。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> K &amp;key, <span class="type">const</span> V &amp;value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 用于记录需要修改的节点</span></span><br><span class="line">  SkipListNode&lt;K, V&gt; *update[MAXL + <span class="number">1</span>];</span><br><span class="line">  SkipListNode&lt;K, V&gt; *p = head;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = level; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;forward[i]-&gt;key &lt; key) &#123;</span><br><span class="line">      p = p-&gt;forward[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第 i 层需要修改的节点为 p</span></span><br><span class="line">    update[i] = p;</span><br><span class="line">  &#125;</span><br><span class="line">  p = p-&gt;forward[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// 若已存在则修改</span></span><br><span class="line">  <span class="keyword">if</span> (p-&gt;key == key) &#123;</span><br><span class="line">    p-&gt;value = value;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取新节点的最大层数</span></span><br><span class="line">  <span class="type">int</span> lv = <span class="built_in">randomLevel</span>();</span><br><span class="line">  <span class="keyword">if</span> (lv &gt; level) &#123;</span><br><span class="line">    lv = ++level;</span><br><span class="line">    update[lv] = head;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 新建节点</span></span><br><span class="line">  SkipListNode&lt;K, V&gt; *newNode = <span class="keyword">new</span> <span class="built_in">SkipListNode</span>&lt;K, V&gt;(key, value, lv);</span><br><span class="line">  <span class="comment">// 在第 0~lv 层插入新节点</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = lv; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    p = update[i];</span><br><span class="line">    newNode-&gt;forward[i] = p-&gt;forward[i];</span><br><span class="line">    p-&gt;forward[i] = newNode;</span><br><span class="line">  &#125;</span><br><span class="line">  ++length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除元素">删除元素</h3><p><img src="/img/algorithm/skip_list_delete.png" alt=""></p><p>删除元素的关键同样是查找操作，先找到待删除元素的位置，然后删除对应元素及其索引，删除操作调整对应指针即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> K &amp;key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 用于记录需要修改的节点</span></span><br><span class="line">  SkipListNode&lt;K, V&gt; *update[MAXL + <span class="number">1</span>];</span><br><span class="line">  SkipListNode&lt;K, V&gt; *p = head;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = level; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;forward[i]-&gt;key &lt; key) &#123;</span><br><span class="line">      p = p-&gt;forward[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第 i 层需要修改的节点为 p</span></span><br><span class="line">    update[i] = p;</span><br><span class="line">  &#125;</span><br><span class="line">  p = p-&gt;forward[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// 节点不存在</span></span><br><span class="line">  <span class="keyword">if</span> (p-&gt;key != key) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 从最底层开始删除</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= level; ++i) &#123;</span><br><span class="line">    <span class="comment">// 如果这层没有 p 删除就完成了</span></span><br><span class="line">    <span class="keyword">if</span> (update[i]-&gt;forward[i] != p) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 断开 p 的连接</span></span><br><span class="line">    update[i]-&gt;forward[i] = p-&gt;forward[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 回收空间</span></span><br><span class="line">  <span class="keyword">delete</span> p;</span><br><span class="line">  <span class="comment">// 删除节点可能导致最大层数减少</span></span><br><span class="line">  <span class="keyword">while</span> (level &gt; <span class="number">0</span> &amp;&amp; head-&gt;forward[level] == tail) --level;</span><br><span class="line">  <span class="comment">// 跳表长度</span></span><br><span class="line">  --length;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度证明">复杂度证明</h2><h3 id="空间复杂度">空间复杂度</h3><p>对于一个节点而言，节点的层数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 的概率为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>p</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p^{i-1}(1-p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0746639999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span>，则该节点的期望层数为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munder><mo>∑</mo><mrow><mi>i</mi><mo>≥</mo><mn>1</mn><mo separator="true">,</mo><mi>p</mi><mo>&lt;</mo><mn>1</mn></mrow></munder><mi>i</mi><msup><mi>p</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>−</mo><mi>p</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\sum_{i\ge 1,p&lt;1}ip^{i-1}(1-p)=\frac{1}{1-p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.463782em;vertical-align:-1.413777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8723309999999997em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">≥</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">p</span><span class="mrel mtight">&lt;</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.413777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">i</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.874664em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.20188em;vertical-align:-0.8804400000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">p</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>则跳表的期望空间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>n</mi><mrow><mn>1</mn><mo>−</mo><mi>p</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{n}{1-p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1764999999999999em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">p</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，且因为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span> 为常数，所以跳表的<strong>期望空间复杂度</strong>为 O(n)。在最坏的情况下，每一层有序链表等于初始有序链表，即跳表的<strong>最差空间复杂度</strong>为 O(nlogn)。</p><h3 id="时间复杂度">时间复杂度</h3><p>从后向前分析查找路径，这个过程可以分为从最底层爬到第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 层和后续操作两个部分。在分析时，假设一个节点的具体信息在它被访问之前是未知的。</p><p>假设当前我们处于一个第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 层的节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>，我们并不知道 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 的最大层数和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 左侧节点的最大层数，只知道 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 的最大层数至少为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>。如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 的最大层数大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>，那么下一步应该是向上走，这种情况的概率为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span>；如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 的最大层数等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>，那么下一步应该是向左走，这种情况概率为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">1-p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span>。</p><p>令 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span> 为在一个无限长度的跳表中向上爬 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 层的期望代价，定义 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">C(0)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，那么有：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>C</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mi>p</mi><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>C</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C(i)=(1-p)(1+C(i))+p(1+C(i-1))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><p>解得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mi>i</mi><mi>p</mi></mfrac></mrow><annotation encoding="application/x-tex">C(i)=\frac{i}{p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.3367719999999998em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.855664em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。</p><p>由此可以得出：在长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 的跳表中，从最底层爬到第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 层的期望步数存在上界 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow><mi>p</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{L(n)-1}{p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.491108em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">n</span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。</p><p>现在只需要分析爬到第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 层后还要再走多少步。易得，到了第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 层后，向左走的步数不会超过第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 层及更高层的节点数总和，而这个总和的期望为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mi>p</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.326216em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。所以到了第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 层后向左走的期望步数存在上界 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mi>p</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.326216em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。同理，到了第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 层后向上走的期望步数存在上界 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mi>p</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.326216em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。</p><p>所以，跳表查询的期望查找步数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow><mi>p</mi></mfrac><mo>+</mo><mfrac><mn>2</mn><mi>p</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{L(n)-1}{p}+\frac{2}{p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.491108em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">n</span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.326216em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，又因为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mfrac><mn>1</mn><mi>p</mi></mfrac></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">L(n)=log_{\frac{1}{p}}n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2786799999999998em;vertical-align:-0.5842399999999999em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.75378em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48288571428571425em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5842399999999999em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span></span></span></span>，所以跳表查询的<strong>期望时间复杂度</strong>为 O(logn)。</p><p>在最坏的情况下，每一层有序链表等于初始有序链表，查找过程相当于对最高层的有序链表进行查询，即跳表查询操作的<strong>最差时间复杂度</strong>为 O(n)。</p><p>插入操作和删除操作就是进行一遍查询的过程，途中记录需要修改的节点，最后完成修改。易得每一层至多只需要修改一个节点，又因为跳表期望层数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mfrac><mn>1</mn><mi>p</mi></mfrac></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_{\frac{1}{p}}n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2786799999999998em;vertical-align:-0.5842399999999999em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.75378em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48288571428571425em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5842399999999999em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span></span></span></span>，所以插入和修改的<strong>期望时间复杂度</strong>也为 O(logn)。</p><h2 id="skiplist-与平衡树、哈希表的比较">skiplist 与平衡树、哈希表的比较</h2><ul><li>skiplist 和各种平衡树（如 AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个 key 的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。</li><li>在做范围查找的时候，平衡树比 skiplist 操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在 skiplist 上进行范围查找就非常简单，只需要在找到小值之后，对第 1 层链表进行若干步的遍历就可以实现。</li><li>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而 skiplist 的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li><li>从内存占用上来说，skiplist 比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而 skiplist 每个节点包含的指针数目平均为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1/(1-p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span>，具体取决于参数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span> 的大小。如果像 Redis 里的实现一样，取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">p=1/4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">4</span></span></span></span>，那么平均每个节点包含 1.33 个指针，比平衡树更有优势。</li><li>查找单个 key，skiplist 和平衡树的时间复杂度都为 O(logn)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近 O(1)，性能更高一些。所以我们平常使用的各种 Map 或 dictionary 结构，大都是基于哈希表实现的。</li><li>从算法实现难度上来比较，skiplist 比平衡树要简单得多。</li></ul><h2 id="参考文献">参考文献</h2><p>[1]  Skip Lists: A Probabilistic Alternative toBalanced Trees<br>[2]  <a href="https://en.wikipedia.org/wiki/Skip_list">Skip list - Wikipedia</a><br>[3]  <a href="http://zhangtielei.com/posts/blog-redis-skiplist.html">Redis内部数据结构详解(6)——skiplist</a><br>[4]  <a href="https://oi-wiki.org/ds/skiplist/">跳表 - OI Wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skiplist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PKI 简介</title>
      <link href="/2023/03/16/crypto-pki/"/>
      <url>/2023/03/16/crypto-pki/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-PKI">什么是 PKI</h2><p>PKI 全称为 Public Key Infrastructure，中文翻译为<strong>公钥基础设施</strong>，是一组由硬件、软件、参与者、管理政策与流程组成的基础架构，其目的在于创造、管理、分配、使用、存储以及撤销<strong>数字证书</strong>。</p><p>在现实世界中，你如何证明自己的身份呢？通常需要权威机构给你颁发一个实体的身份证明证件，这个证件包含着标识你的唯一 ID 和一些基本信息，可能还会包含着你的指纹和面部识别信息等生物特征。这样你可以通过这个证件来证明你的身份，验证你的身份，可以通过比对证件所记录的信息是否与你的生物特征匹配。</p><p>那么在网络世界如何标识一个个体的身份呢，除此之外，我们还需要安全的传输信息，由此诞生了 PKI。我们知道通过公私密钥对可以安全地传输消息，但是我们怎么获取要传输信息对象的公钥呢，PKI 将公钥与身份绑定在一起。</p><p>PKI 安全性最初出现在 1990 年代，旨在通过颁发和管理数字证书来帮助管理加密密钥。这些 PKI 证书验证私钥的所有者以及该关系的真实性，这些证书类似于数字世界的驾驶执照或护照。我们最常见的 PKI 包含在 HTTPS 协议中，通过 SSL 证书维护安全性，以便网站访问者知道他们正在将信息发送给预期的接收人。</p><h2 id="PKI-结构">PKI 结构</h2><p><img src="/img/crypto/PKI_architecture.png" alt="PKI architecture"></p><p>如图所示，PKI 由以下几部分构成：</p><ul><li>PKI entity：使用 PKI 证书的最终用户。PKI 实体可以是操作员、组织、路由器或交换机等设备，也可以是计算机上运行的进程。PKI 实体使用 SCEP 与 CA 或 RA 通信。</li><li>CA：授予和管理证书的证书颁发机构。CA 颁发证书、定义证书有效期并通过发布 CRL 吊销证书。</li><li>RA：注册机构，通过处理证书注册请求来减轻 CA 工作负担。RA 接受证书请求，验证用户身份，并确定是否要求 CA 颁发证书。RA 在 PKI 系统中是可选的。如果存在将 CA 公开给直接网络访问的安全问题，建议将某些任务委托给 RA。然后，CA 可以专注于其签署证书和 CRL 的主要任务。</li><li>Certificate/CRL repository：存储证书和 CRL（Certificate Revocation List） 并将这些证书和 CRL 分发到 PKI 实体的证书分发点。它还提供查询功能。PKI 存储库可以是使用 LDAP 或 HTTP 协议的目录服务器，其中通常使用 LDAP。</li></ul><h3 id="数字证书">数字证书</h3><p>PKI 通过颁发和管理数字证书来管理加密密钥。数字证书也称为 X.509 证书和 PKI 证书。数字证书绑定到加密密钥对，用于验证网站、个人、组织、用户、设备或服务器的身份。证书包含主体（即身份标识）以及数字签名。<br>数字证书具有以下特性：</p><ol><li>是相当于驾驶执照或护照的电子文档；</li><li>包含有关个人或实体的信息；</li><li>由受信任的第三方颁发；</li><li>防篡改；</li><li>包含可以证明其真实性的信息；</li><li>可以追溯到发行者；</li><li>有一个到期日期；</li><li>提供给某人（或某物）进行验证。</li></ol><h3 id="数字证书创建过程">数字证书创建过程</h3><p><img src="/img/crypto/PKI-Certificate-Creation-Process.png" alt="PKI-Certificate-Creation-Process"><br>证书创建过程如下：</p><ul><li>创建私钥并计算相应的公钥；</li><li>CA 请求私钥所有者的标识属性并审查该信息；</li><li>公钥和标识属性被编码到证书签名请求 （CSR） 中；</li><li>CSR 由密钥所有者签名以证明拥有该私钥；</li><li>CA 验证请求并使用自己的私钥对证书进行签名；</li></ul><h3 id="CA-层级结构">CA 层级结构</h3><p><img src="/img/crypto/PKI-CA-Hierarchies-and-Root-CAs.png" alt="PKI-CA-Hierarchies-and-Root-CAs"><br>每个 CA 都有自己的证书，信任层通过 CA 层次结构创建，上层 CA 为下层 CA 颁发证书。存根证书是最初信任来源，根证书是自签名的，人们必须从本质上信任根证书颁发机构来信任可追溯到它的任何证书。为了满足最高的安全标准，根 CA 几乎不应处于联机状态。信任链如下图所示：</p><p><img src="/img/crypto/Chain_of_trust_v2.svg.png" alt="Chain_of_trust_v2"></p><h2 id="参考文献">参考文献</h2><p>[1]  <a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E5%9F%BA%E7%A4%8E%E5%BB%BA%E8%A8%AD">公开密钥基础建设 - 维基百科 </a><br>[2]  <a href="https://techhub.hpe.com/eginfolib/networking/docs/switches/5130ei/5200-3946_security_cg/content/485048341.htm">PKI architecture</a><br>[3]  <a href="https://www.keyfactor.com/resources/what-is-pki/">What is PKI?</a><br>[4]  <a href="https://en.wikipedia.org/wiki/Public_key_certificate">Public key certificate - Wikipedia</a></p>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PKI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机安装 Arch Linux</title>
      <link href="/2022/11/24/vmware-install-archlinux/"/>
      <url>/2022/11/24/vmware-install-archlinux/</url>
      
        <content type="html"><![CDATA[<h2 id="背景">背景</h2><p>关于图形界面与命令行界面各有优势，在编译项目的场景下，更倾向于运行命令脚本自动化构建，但是在Windows系统中搭建Shell环境及其复杂，往往功能不全，很容易出现各种小问题。在Windows中也有很多模拟Linux环境的应用，最常见的有Cygwin，MSYS2，WSL等，我使用过其中的几个，使用体验不佳，普遍存在很多问题，而且极易造成系统混乱。那么问题来了，如何优雅的在Windows中使用Linux系统，我觉得最佳方案应该是部署Linux云服务器，这种方法成本比较高；那么另一种方案就是虚拟机了，但是虚拟机性能不高，为此，我选择了可以最小化安装的Arch Linux。</p><h2 id="安装">安装</h2><h3 id="软硬件准备">软硬件准备</h3><p>在虚拟机中新建一个客户机，硬件配置自行选择，网络适配器选择NAT模式，参见<a href="https://zhuanlan.zhihu.com/p/447380486">虚拟机VMware Workstation Pro v16.0.0使用教程</a>，下载最新的<a href="https://archlinux.org/download/">Arch Live ISO</a>，注意一定要选择最新的镜像，老版本镜像可能存在公钥过时问题。</p><h3 id="安装步骤">安装步骤</h3><p>相比于在真实主机中安装Linux系统，在虚拟机中安装要简单很多，不需要考虑网络连接、硬件驱动、兼容性等很多问题。</p><p>从镜像中启动系统，对于BIOS固件，Live ISO 使用syslinux作为引导程序；对于UEFI固件，Live ISO 使用GRUB作为引导程序，安装时不必过多在意这些。不同版本的镜像以及固件方式不同，引导界面显示内容不同，通常会有以下几下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Arch Linux install medium (x86_64, UEFI)</span><br><span class="line">Arch Linux install medium (x86_64, UEFI) with speech</span><br><span class="line">EFI Shell</span><br><span class="line">Reboot Into Firmware Interface</span><br></pre></td></tr></table></figure><p>通常选择第一项即可，第二项提供了一个语音功能的无障碍安装模式，后面是一些进入固件的选项。</p><p>会以 root 用户进入 Live 系统：<br><img src="/img/linux/archlinux_1.png" alt="在这里插入图片描述"></p><p>英语区与中文区通常不需要更改默认键盘布局(US)，确认固件类型：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /sys/firmware/efi/efivars</span><br></pre></td></tr></table></figure><p>上述命令有输出内容则为UEFI启动，若文件夹不存在则为BIOS启动，虚拟机创建客户机时如果没有更改固件类型默认为BIOS模式。</p><p>检查网络连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip <span class="built_in">link</span></span><br><span class="line">ping archlinux.org</span><br></pre></td></tr></table></figure><p>因为创建客户机时网络适配器选择的是NAT模式，此处网络连接应该会自动配置完成，即运行 ip link 输出中有IPv4地址，ping 命令测试可以连通。</p><p>接下来，对硬盘分区，使用 fdisk 或者 lsblk 列出可用硬盘：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure><p>在虚拟机中上述命令输出结果通常为 /dev/sda，Live ISO 中提供了fdisk、gdisk、parted等分区工具，使用 fdisk 命令分区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sda</span><br></pre></td></tr></table></figure><p>根据命令提示完成分区操作，推荐分区如下：</p><p><strong>BIOS with</strong> MBR</p><table><thead><tr><th>挂载点</th><th>分区</th><th>分区类型</th><th>建议大小</th></tr></thead><tbody><tr><td>[SWAP]</td><td>/dev/swap_partition</td><td>Linux swap</td><td>512MiB</td></tr><tr><td>/mnt</td><td>/dev/root_partition</td><td>Linux</td><td>磁盘剩余空间</td></tr></tbody></table><p>UEFI with GPT：</p><table><thead><tr><th>挂载点</th><th>分区</th><th>分区类型</th><th>建议大小</th></tr></thead><tbody><tr><td>/mnt/boot</td><td>/dev/efi_system_partition</td><td>EFI system partition</td><td>512MiB</td></tr><tr><td>[SWAP]</td><td>/dev/swap_partition</td><td>Linux swap</td><td>512MiB</td></tr><tr><td>/mnt</td><td>/dev/root_partition</td><td>Linux x86-64 root (/)</td><td>磁盘剩余空间</td></tr></tbody></table><p>创建好分区之后，格式化分区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 /dev/root_partition             <span class="comment"># 根分区文件类型为ext4</span></span><br><span class="line">mkswap /dev/swap_partition                <span class="comment"># 交换分区</span></span><br><span class="line">mkfs.fat -F 32 /dev/efi_system_partition  <span class="comment"># EFI分区类型为FAT32</span></span><br></pre></td></tr></table></figure><p>挂在分区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/root_partition /mnt            <span class="comment"># 挂载根分区</span></span><br><span class="line"><span class="built_in">mkdir</span> /mnt/boot                           <span class="comment"># 创建EFI分区挂载点</span></span><br><span class="line">mount /dev/efi_system_partition /mnt/boot <span class="comment"># 挂载EFI分区</span></span><br><span class="line">swapon /dev/swap_partition                <span class="comment"># 激活交换分区</span></span><br></pre></td></tr></table></figure><p>接下来将系统安装到刚刚分区的硬盘中，使用 pacstrap 脚本将 Live ISO 中的文件复制到硬盘中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacstrap -K /mnt base linux vim</span><br></pre></td></tr></table></figure><p>虚拟机中只需要最小化安装 base 和 linux 组件，不需要安装 linux-firmware，将 vim 安装进去便于编辑文件。</p><p>创建 fstab 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure><p>进入新系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arch-chroot /mnt</span><br></pre></td></tr></table></figure><p>设置时区，此处设置为国内时区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">hwclock --systohc</span><br></pre></td></tr></table></figure><p>语言建议默认选择英文。创建 hostname 与 hosts 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/etc/hostname</span><br><span class="line">myhostname</span><br><span class="line"></span><br><span class="line">/etc/hosts</span><br><span class="line">127.0.0.1        localhost</span><br><span class="line">::1              localhost</span><br><span class="line">127.0.1.1        myhostname</span><br></pre></td></tr></table></figure><p>更改镜像，国内使用 Arch 官方镜像速度很慢，改为国内镜像，编辑 /etc/pacman.d/mirrorlist 文件（建议更改系统文件时先备份再更改）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server = http://mirrors.aliyun.com/archlinux/$repo/os/$arch</span><br></pre></td></tr></table></figure><p>设置 root 密码，创建远程登陆用户（ssh禁止使用 root 用户远程登陆）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">passwd                 <span class="comment"># 连续输入两次密码</span></span><br><span class="line">groupadd group1        <span class="comment"># 创建用户组 group1</span></span><br><span class="line">useradd -m -g group1 -s /bin/bash <span class="built_in">test</span> <span class="comment"># 创建用户 test，加入 group1 组 </span></span><br><span class="line">passwd <span class="built_in">test</span>            <span class="comment"># 为用户 test 创建密码</span></span><br></pre></td></tr></table></figure><p>编辑 /etc/sudoers 文件，对创建的 test 用户赋予执行 sudo 的权限。</p><p>安装相关软件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman -S dhcpcd         <span class="comment"># DHCP 客户端</span></span><br><span class="line">pacman -S openssh        <span class="comment"># 远程登陆服务端</span></span><br><span class="line">pacman -S open-vm-tools  <span class="comment"># 开源实现的 VMTools</span></span><br></pre></td></tr></table></figure><p>安装 CPU microcode：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacman -S amd-ucode    <span class="comment"># AMD CPU</span></span><br><span class="line">pacman -S intel-ucode  <span class="comment"># Intel CPU</span></span><br></pre></td></tr></table></figure><p>安装启动引导程序，启动引导程序有很多，常见的有GRUB（支持 BIOS 与 UEFI）、rEFInd（支持 UEFI），选择 GRUB 作为启动引导程序：</p><p>BIOS 启动模式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman -S grub </span><br><span class="line">grub-install --target=i386-pc /dev/sda </span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg  <span class="comment"># 生成 grub.cfg 文件</span></span><br></pre></td></tr></table></figure><p>UEFI 启动模式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman -S grub efibootmgr  <span class="comment"># 需要安装 efibootmgr</span></span><br><span class="line">grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB </span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg  <span class="comment"># 生成 grub.cfg 文件</span></span><br></pre></td></tr></table></figure><p>完成上述步骤后，重启系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span>          <span class="comment"># 退出 arch-chroot</span></span><br><span class="line">shutdown now  <span class="comment"># 关机</span></span><br></pre></td></tr></table></figure><p>关机后需要移除 ISO 镜像才能重新启动，进入系统后执行如下操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> systemd-networkd systemd-resolved dhcpcd sshd  <span class="comment"># 设置网络相关软件自启动</span></span><br><span class="line">systemctl start systemd-networkd systemd-resolved dhcpcd sshd   <span class="comment"># 启动网络相关软件</span></span><br><span class="line">ip <span class="built_in">link</span>             <span class="comment"># 查看网卡</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> up eth1 <span class="comment"># 激活网卡，eth1 为上述命令输出的网卡名</span></span><br><span class="line">dhcpcd              <span class="comment"># 运行 DHCP</span></span><br></pre></td></tr></table></figure><p>经过上述操作，虚拟机应该可以正常连接到网络，如果不行，就重启一下虚拟机。然后查看虚拟机 IP 地址，从 Window 中用 ssh 协议登陆到虚拟机，这样在就可以实现复制粘贴功能，推荐一款开源的跨平台终端 <a href="https://tabby.sh/">Tabby</a>,主机与虚拟机的文件传输，可以使用 Tabby 终端附带的 SFTP 协议或者虚拟机的共享文件夹功能。<br><img src="/img/linux/archlinux_2.webp" alt="在这里插入图片描述"></p><p>在配置完 C 运行环境之后，系统占用仅仅2.3G，相比于其他发行版本，真的精简很多，适合在虚拟机中运行，减少不必要的性能开销。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux网络配置（二）</title>
      <link href="/2022/10/31/Linux-network-configuration2-md/"/>
      <url>/2022/10/31/Linux-network-configuration2-md/</url>
      
        <content type="html"><![CDATA[<h2 id="检查网卡">检查网卡</h2><p>查看网卡是否存在以及相应模块是否加载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lspci 命令用于显示 Linux 系统上的设备和驱动程序</span></span><br><span class="line">lspci -k</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Ethernet controller 为有线网卡（以太网卡）</span></span><br><span class="line">02:05.0 Ethernet controller: Intel Corporation 82545EM Gigabit Ethernet Controller (Copper) (rev 01)</span><br><span class="line">        DeviceName: Ethernet1</span><br><span class="line">        Subsystem: VMware PRO/1000 MT Single Port Adapter</span><br><span class="line">        Kernel driver <span class="keyword">in</span> use: e1000</span><br><span class="line">        Kernel modules: e1000</span><br><span class="line">        </span><br><span class="line"><span class="comment">## Network controller 为无线网卡（WIFI网卡）</span></span><br><span class="line">06:00.0 Network controller: Intel Corporation WiFi Link 5100</span><br><span class="line">Subsystem: Intel Corporation WiFi Link 5100 AGN</span><br><span class="line">Kernel driver <span class="keyword">in</span> use: iwlwifi</span><br><span class="line">Kernel modules: iwlwifi</span><br><span class="line"></span><br><span class="line"><span class="comment"># dmesg 命令是用于显示内核的相关信息，用该命令查看相关驱动是否成功加载，module_name 为上述命令输出的模块名</span></span><br><span class="line">dmesg | grep module_name </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[   13.726383] e1000: ens37 NIC Link is Up 1000 Mbps Full Duplex</span><br></pre></td></tr></table></figure><p>如果网卡存在，驱动没有正确加载，则需要先安装相应的驱动。</p><p>无线网卡可以通过 USB 接入系统（例如在虚拟机中，想要直接通过无线网卡连接 WiFi，可通过 USB 外接无线网卡的形式实现），此时查看可用 lsusb 命令查看无线网卡信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lsusb -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Wireless Adapter 为无线网卡</span></span><br><span class="line">Bus 001 Device 002: ID 7392:7811 Edimax Technology Co., Ltd EW-7811Un 802.11n Wireless Adapter [Realtek RTL8188CUS]</span><br></pre></td></tr></table></figure><h2 id="连接网络">连接网络</h2><h3 id="有线网络">有线网络</h3><h4 id="以太网">以太网</h4><p>激活以太网卡，插入网线，基本就可以连接到网络了，一般不需要选择网络和输入密码，如果网络未连接，则检查网卡，网络通路等。</p><h4 id="PPPoE">PPPoE</h4><p>PPPoE 是一种拨号上网（ADSL），连接这种类型的网络需要输入用户名与密码进行认证。对于 DEB 包发行版，安装 pppoeconf 包；对于 RPM 包发行版，安装 rp-pppoe 包。</p><p>以 rp-pppoe 包为例展示设置网络的过程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pppoe-setup    <span class="comment"># 配置PPPoE连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入用户名：</span></span><br><span class="line"><span class="comment"># 输入以太网卡代号：（根据实际网卡名配置）</span></span><br><span class="line"><span class="comment"># 配置：若长时间连线，连线会被自动中断：（选no）</span></span><br><span class="line"><span class="comment"># 配置主DNS服务器：（无需配置或者114.114.114.114）</span></span><br><span class="line"><span class="comment"># 配置次DNS服务器：（无需配置或者8.8.8.8）</span></span><br><span class="line"><span class="comment"># 两次输入账户密码以确认（宽带密码，输入没有不显示“*”，如果输错，会提示是否重新输入，选择y）</span></span><br><span class="line"><span class="comment"># 配置普通账户是否有网络连接权限（y或者n）</span></span><br><span class="line"><span class="comment"># 配置防火墙（没有特殊需求选0不配置）</span></span><br><span class="line"><span class="comment"># 配置是否开机自动拨号连接（yes或no）</span></span><br><span class="line"><span class="comment"># 确认刚填写的配置信息（y或n）</span></span><br><span class="line"></span><br><span class="line">pppoe-connect [configuration_file_path] <span class="comment"># 建立连接</span></span><br><span class="line">pppoe-start [configuration_file_path]   <span class="comment"># 启动软件进行连接，当出现“Connected”就表示连接成功了</span></span><br><span class="line">pppoe-stop [configuration_file_path]    <span class="comment"># 关闭连接</span></span><br><span class="line">pppoe-status     <span class="comment"># 查看网络状态</span></span><br></pre></td></tr></table></figure><p>pppoe-setup 生成的配置文件是 /etc/ppp/pppoe.conf，可以修改该文件调整参数，用户名与密码存储在 /etc/ppp/chap-secrets 文件中。</p><h3 id="无线网络">无线网络</h3><h4 id="普通无线网络">普通无线网络</h4><p>目前很少有开放 WIFI，即连接 WIFI 不需要输入密码，大部分 WIFI 网络都需要进行密码验证。连接无线网络可以使用网络管理软件或者以下工具：</p><table><thead><tr><th style="text-align:center">Software</th><th style="text-align:center">Package</th><th style="text-align:center">WEXT</th><th style="text-align:center">nl80211</th><th style="text-align:center">WEP</th><th style="text-align:center">WPA/WPA2</th></tr></thead><tbody><tr><td style="text-align:center">wireless_tools</td><td style="text-align:center">wireless_tools</td><td style="text-align:center">Yes</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td><td style="text-align:center">No</td></tr><tr><td style="text-align:center">iw</td><td style="text-align:center">iw</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">No</td></tr><tr><td style="text-align:center">wpa_supplicant</td><td style="text-align:center">wpa_supplicant</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td></tr><tr><td style="text-align:center">iwd</td><td style="text-align:center">iwd</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td></tr></tbody></table><h5 id="wireless-tools">wireless_tools</h5><p>Wireless Extension (WE)是一组通用的 API，能在用户空间对通用 Wireless LANs 进行配置和统计，Wireless Tools (WT)就是用来操作Wireless Extensions的工具集。常用命令为 iwconfig iwlist.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iwlist wlan0 scan   <span class="comment"># 扫描可用的 WIFI 接入点</span></span><br><span class="line">iwconfig wlan0      <span class="comment"># 查看连接状态</span></span><br><span class="line">iwconfig wlan0 essid your_essid   <span class="comment"># 连接一个开放的 WIFI</span></span><br><span class="line">iwconfig wlan0 essid your_essid key s:your_key  <span class="comment"># 连接一个 WEP 加密的 WIFI，密码为 ASCII 格式</span></span><br></pre></td></tr></table></figure><h5 id="iw">iw</h5><p>iw 是一种新的基于 nl80211 的用于无线设备的 CLI 配置实用程序，iw 取代了采用无线扩展接口的旧工具iwconfig。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iw dev  <span class="comment"># 显示网卡</span></span><br><span class="line">iw dev wlan0 scan   <span class="comment"># 扫描可用的 WIFI 接入点</span></span><br><span class="line">iw dev wlan0 <span class="built_in">link</span>   <span class="comment"># 查看连接状态</span></span><br><span class="line">iw dev wlan0 connect your_essid  <span class="comment"># 连接一个开放的 WIFI</span></span><br><span class="line">iw dev wlan0 connect your_essid key d:0:your_key  <span class="comment"># 连接一个 WEP 加密的 WIFI，密码为 ASCII 格式，d：default，0：表示第0个密码</span></span><br></pre></td></tr></table></figure><h5 id="wpa-supplicant">wpa_supplicant</h5><p>iwconfig 和 iw 只能连接采用 WEP 加密方式的 WIFI。WPA（Wi-Fi Protected Access），意即“Wi-Fi访问保护”，是一种由Wi-Fi联盟制订与发布，用来保护无线网络（Wi-Fi）访问安全的技术标准。前一代有线等效加密（Wired Equivalent Privacy, WEP）系统中，被发现若干严重的弱点，因此Wi-Fi联盟推出WPA、WPA2与WPA3系列来加强无线网络安全。wpa_supplicant是一个开源项目，已经被移植到Linux，Windows以及很多嵌入式系统上。它是WPA的应用层认证客户端，负责完成认证相关的登录、加密等工作。</p><p>使用 wpa_cli 命令配置网络连接，首先需要创建一个配置文件 /etc/wpa_supplicant/wpa_supplicant.conf，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctrl_interface=/run/wpa_supplicant</span><br><span class="line">update_config=1</span><br></pre></td></tr></table></figure><p>然后开启 wpa_supplicant：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wpa_supplicant -B -i wlan0 -c /etc/wpa_supplicant/wpa_supplicant.conf</span><br></pre></td></tr></table></figure><p>然后运行 wpa_cli：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">wpa_cli</span><br><span class="line"></span><br><span class="line">&gt; scan            <span class="comment"># 使用 scan 扫描网络</span></span><br><span class="line">&lt;3&gt;CTRL-EVENT-SCAN-RESULTS</span><br><span class="line">&gt; scan_results    <span class="comment"># 使用 scan_results显示扫描结果</span></span><br><span class="line">bssid / frequency / signal level / flags / ssid</span><br><span class="line">00:00:00:00:00:00 2462 -49 [WPA2-PSK-CCMP][ESS] MYSSID</span><br><span class="line">11:11:11:11:11:11 2437 -64 [WPA2-PSK-CCMP][ESS] ANOTHERSSID</span><br><span class="line">&gt; add_network     <span class="comment"># 添加网络</span></span><br><span class="line">0</span><br><span class="line">&gt; set_network 0 ssid <span class="string">&quot;MYSSID&quot;</span>     <span class="comment"># 选择网络</span></span><br><span class="line">&gt; set_network 0 psk <span class="string">&quot;passphrase&quot;</span>  <span class="comment"># 输入密码，如果没有密码使用：set_network 0 key_mgmt NONE</span></span><br><span class="line">&gt; enable_network 0                <span class="comment"># 开启连接</span></span><br><span class="line">&gt; save_config      <span class="comment"># 保存</span></span><br><span class="line">OK</span><br><span class="line">&gt; quit    <span class="comment"># 退出</span></span><br></pre></td></tr></table></figure><h5 id="iwd">iwd</h5><p><a href="https://iwd.wiki.kernel.org/">iwd</a> (iNet wireless daemon，iNet 无线守护程序) 是由英特尔（Intel）为 Linux 编写的一个无线网络守护程序。该项目的核心目标是不依赖任何外部库，而是最大程度地利用 Linux 内核提供的功能来优化资源利用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iwctl   <span class="comment"># 进入交互式提示符</span></span><br><span class="line">&gt; <span class="built_in">help</span>  <span class="comment"># 列出所有可用的命令</span></span><br><span class="line">&gt; device list         <span class="comment"># 列出所有 WiFi 设备</span></span><br><span class="line">&gt; station wlan0 scan  <span class="comment"># 扫描网络</span></span><br><span class="line">&gt; station wlan0 get-networks    <span class="comment"># 列出所有可用的网络</span></span><br><span class="line">&gt; station wlan0 connect SSID    <span class="comment"># 连接到一个网络，如果要求输入网络密码，将会提示用户输入</span></span><br></pre></td></tr></table></figure><p>此外，连接操作可以应用成命令行参数的形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iwctl --passphrase your_key station wlan0 connect SSID</span><br></pre></td></tr></table></figure><h4 id="使用网页认证的无线网络">使用网页认证的无线网络</h4><p>现在有很多 WIFI 使用了网页认证（<a href="https://link.zhihu.com/?target=https%3A//www.wikiwand.com/en/Captive_portal">Captive Portal</a>），Captive portal，又名强制网络门户、强制主页，是在授予新连接至 WIFI 或接受最终用户许可协议/可接受使用策略的着陆页或登录页。强制门户应用于方方面面的移动宽带服务中（如有线连接、计费Wi-Fi及家庭热点），同时也可提供对企业或家庭有线网络（公寓、酒店和商业中心的网络）的访问权限。</p><p>这种网络通过 Web + DHCP 认证方式解决无线用户接入问题，常见于无线校园网中。通常主机连接上无线网络后，DHCP服务器就会给主机分配一个 IP 地址，如果用户没有认证登录，在浏览器访问的任何 IP 地址都会被重定向到 WEB 认证页面。Windows和安卓系统在连接到网络后一般会自动跳出登录界面；而在linux中，当连接上此类 WIFI 时可能并不会弹出网页认证的界面，解决方法如下：</p><ol><li><a href="https://wiki.archlinux.org/title/NetworkManager#Captive_portals">NetworkManager/Captive portals</a></li><li><a href="https://github.com/FiloSottile/captive-browser">captive-browser-git</a></li></ol><h2 id="参考文献">参考文献</h2><p>[1] <a href="https://wiki.archlinux.org/title/Network_configuration/Ethernet">Network configuration/Ethernet</a><br>[2] <a href="https://wiki.archlinux.org/title/Network_configuration/Wireless">Network configuration/Wireless</a><br>[3] <a href="https://blog.csdn.net/qq_26733603/article/details/109682400">在Linux操作系统下的PPPoE拨号上网</a><br>[4] <a href="https://zh.m.wikipedia.org/zh-hans/%E5%BC%BA%E5%88%B6%E9%97%A8%E6%88%B7">强制门户</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 网络配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux网络配置（一）</title>
      <link href="/2022/10/31/Linux-network-configuration1-md/"/>
      <url>/2022/10/31/Linux-network-configuration1-md/</url>
      
        <content type="html"><![CDATA[<h2 id="网络配置">网络配置</h2><p>大家平时经常碰到的网络是局域网（LAN），局域网又分为有线局域网和无线局域网（WLAN），其中以太网（Ethernet）是最常见的有线局域网，WIFI是最常见的无线局域网。除此之外，还有拨号网络PPPoE（Point-to-Point Protocol over Ethernet），即以太网上的点对点协议（PPP）。以太网技术虽然具有简单易用，成本低等特点，但是以太网广播网络的属性，使得其通信双方无法相互验证对方的身份，因而通信是不安全的；PPPoE结合了PPP协议通信双方身份验证的功能，在PPP组网结构的基础上，将PPP报文封装成PPPoE报文，从而实现以太网上的点对点通信，使得以太网中的客户端能够连接到远端的宽带接入设备上，实现了传统以太网不能提供的身份验证、加密以及压缩等功能。</p><p>本文描述如何在 Linux 系统中配置 ISO 模型的网络层（Network Layer）连接。</p><h3 id="网络连接">网络连接</h3><p>首先确保电脑中装有网卡，排查网络是否连接的详细步骤如下：</p><ol><li>检查网卡是列出在和启用，如果没有，则检查网卡驱动程序是否加载；</li><li>电脑连接到网络，有线网络（Ethernet）或者无线网络（wireless LAN）；</li><li>检查网卡是否有一个 IP 地址；</li><li>正确配置路由表；</li><li>检查是否可以 ping 通本地 IP 地址（如默认网关）；</li><li>检查是否可以 ping 通公网 IP 地址（如 9.9.9.9，该 IP 为一个 DNS 服务器）；</li><li>检查是否可以 ping 通一个网络域名（如 <a href="http://archlinux.org">archlinux.org</a>）.</li></ol><p>首先介绍一些网络管理工具。</p><h4 id="ping-命令">ping 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ping domain_name/ip_address <span class="comment"># ping 后面的测试可以是网站域名或者 IP 地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：</span></span><br><span class="line">ping archlinux.org</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">PING archlinux.org (95.217.163.246) 56(84) bytes of data.</span><br><span class="line">64 bytes from archlinux.org (95.217.163.246): icmp_seq=1 ttl=128 time=279 ms</span><br><span class="line">64 bytes from archlinux.org (95.217.163.246): icmp_seq=2 ttl=128 time=234 ms</span><br><span class="line">64 bytes from archlinux.org (95.217.163.246): icmp_seq=3 ttl=128 time=233 ms</span><br><span class="line">^C</span><br><span class="line">--- archlinux.org ping statistics ---</span><br><span class="line">4 packets transmitted, 3 received, 25% packet loss, time 3090ms</span><br><span class="line">rtt min/avg/max/mdev = 232.841/248.541/278.688/21.323 ms</span><br></pre></td></tr></table></figure><p>ping 命令包含在 <a href="https://github.com/iputils/iputils">iputils</a>包中，在一些精简的系统中，要使用 ping 命令首先需要安装 iputils 包。使用 Ctrl+c 即可终止输出，从输出结果中可以看出测试结果，需要注意 ping 命令测试是运行的是网络层中 ICMP 协议， 当代理软件运行在应用层时，不能用该命令测试网络的连通性。</p><h4 id="net-tools">net-tools</h4><p>net-tools 包含了一系列 Linux 网络的基础程序，其中最常见的有 arp ifconfig netstat route.</p><h5 id="arp">arp</h5><p>ARP（Address Resolution Protocol，地址解析协议）是用来将IP地址解析为MAC地址的协议。 主机或三层网络设备上会维护一张ARP表，用于存储IP地址和MAC地址的映射关系，一般ARP表项包括动态ARP表项和静态ARP表项。</p><p>arp 命令用于操作内核 ARP 缓存，一般很少需要手动操作 ARP 表项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arp -v                   <span class="comment"># 显示 arp 缓冲区内容</span></span><br><span class="line">arp -s IP MAC-ADDRESS    <span class="comment"># 添加静态 arp 映射　</span></span><br><span class="line">arp -d IP                <span class="comment"># 删除 arp 缓存条目</span></span><br></pre></td></tr></table></figure><h5 id="ifconfig-network-interfaces-configuring">ifconfig (network interfaces configuring)</h5><p>ifconfig 是配置网卡的主要命令，其功能是用于显示或设置网络设备参数信息，在Windows系统中与之类似的命令叫做 ipconfig，使用 ifconfig 命令配置网络设备的参数信息临时生效，当服务器重启，配置过的参数会自动失效，如果需要永久改变，则需要写入配置文件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法格式：ifconfig [网卡设备] [参数]</span></span><br><span class="line">ifconfig        <span class="comment"># 显示网卡信息</span></span><br><span class="line">ifconfig -a     <span class="comment"># 显示的是系统所有的网络接口，不管是激活的还是未激活的</span></span><br><span class="line">ifconfig network_interface up/down    <span class="comment"># 对指定的网卡设备进行启动或关闭操作</span></span><br><span class="line">ifconfig network_interface 192.168.10.20 netmask 255.255.255.0  <span class="comment"># 临时修改IP地址</span></span><br></pre></td></tr></table></figure><p>注意一下网卡的命名规则，默认情况下，udev 分配网卡名字，以太网前缀 en，WIFI 前缀 wl.</p><h5 id="netstat">netstat</h5><p>netstat是控制台命令,是一个监控TCP/IP网络的非常有用的工具，它可以显示路由表、实际的网络连接以及每一个网络接口设备的状态信息。Netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">netstat -ltup</span><br><span class="line"><span class="comment"># -l 只显示监听端口</span></span><br><span class="line"><span class="comment"># -t 列出 tcp 端口</span></span><br><span class="line"><span class="comment"># -u 列出 udp 端口</span></span><br><span class="line"><span class="comment"># -p 输出中显示 PID 和进程名称</span></span><br></pre></td></tr></table></figure><p>实际使用中可以用 grep 命令过滤输出。</p><h5 id="route">route</h5><p>route 命令是用于操作基于内核 IP 路由表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">route -n   <span class="comment"># 显示当前路由</span></span><br><span class="line">oute add/del -net ip_addr netmask ip_addr dev net_interface  <span class="comment"># 添加网/删除网关</span></span><br><span class="line">route add/del default gw ip_addr  <span class="comment"># 添加/删除设置默认网关</span></span><br></pre></td></tr></table></figure><h4 id="traceroute">traceroute</h4><p>traceroute 用于探测数据包从源到目的经过路由的 IP，使用该命令前需要安装 traceroute 包。traceroute 的原理是试图以最小的 TTL（存活时间）发出探测包来跟踪数据包到达目标主机所经过的网关，然后监听一个来自网关 ICMP 的应答。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例：</span></span><br><span class="line">traceroute archlinux.org</span><br></pre></td></tr></table></figure><h4 id="iproute2">iproute2</h4><p>iproute2 的出现旨在从功能上取代 net-tools，net-tools 通过procfs(/proc)和ioctl系统调用去访问和改变内核网络配置，而iproute2则通过netlink套接字接口与内核通讯。抛开性能而言，iproute2的用户接口比net-tools显得更加直观。</p><p>iproute2 的核心命令是 ip 命令，它与 net-tools 中命令的对应关系如下：</p><table><thead><tr><th style="text-align:left">net-tools command</th><th style="text-align:left">iproute2 commands</th></tr></thead><tbody><tr><td style="text-align:left">arp</td><td style="text-align:left">ip neighbor</td></tr><tr><td style="text-align:left">ifconfig</td><td style="text-align:left">ip address, ip link</td></tr><tr><td style="text-align:left">netstat</td><td style="text-align:left">ss</td></tr><tr><td style="text-align:left">route</td><td style="text-align:left">ip route</td></tr></tbody></table><p>ip 命令用法示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ip <span class="built_in">link</span> show                      <span class="comment"># 显示出所有可用网络接口的列表</span></span><br><span class="line">ip addr [show dev eth1]           <span class="comment"># 查看某个指定网络接口的IPv4地址</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> up/down eth1          <span class="comment"># 激活或停用某个指定的网络接口</span></span><br><span class="line">ip addr add 10.0.0.1/24 [broadcast 10.0.0.255] dev eth1  <span class="comment"># 可以使用 iproute2 给同一个接口分配多个 IP 地址</span></span><br><span class="line">ip addr del 10.0.0.1/24 dev eth1  <span class="comment"># 移除 IP 地址</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> dev eth1 address 08:00:27:75:2a:67  <span class="comment"># 更改网络接口的MAC地址</span></span><br></pre></td></tr></table></figure><h4 id="DHCP">DHCP</h4><p>通常情况下我们不需要手动配合静态 IP，只需要去动态获取 IP 即可。一个网络中的 DHCP 服务器给客户端提供了动态 IP 地址、子网掩码、默认网关，以及可选的 DNS 服务。</p><p>在客户端安装 DHCP 的客户端即可使用该服务。Linux 上常用的 DHCP 客户端是 dhcpcd，如下表所示：</p><table><thead><tr><th style="text-align:center">Client</th><th style="text-align:center">Package</th><th style="text-align:center">Note</th><th style="text-align:center">Systemd units</th></tr></thead><tbody><tr><td style="text-align:center">dhcpcd</td><td style="text-align:center">dhcpcd</td><td style="text-align:center">DHCP, DHCPv6, ZeroConf, static IP</td><td style="text-align:center"><code>dhcpcd.service</code>, <code>dhcpcd@*interface*.service</code></td></tr></tbody></table><p>很多网络管理软件都内置了 DHCP 服务。</p><h2 id="网络管理软件">网络管理软件</h2><p>介绍几种网络管理软件，这些网络管理软件用于管理网络连接。使用这些软件很大程度上降低了网络连接的复杂性。常用的网络管理软件如下：</p><table><thead><tr><th style="text-align:center">Network manager</th><th style="text-align:center">GUI</th><th style="text-align:center">CLI tools</th><th style="text-align:center">PPP support</th><th style="text-align:center">DHCP client</th><th style="text-align:center">systemd units</th></tr></thead><tbody><tr><td style="text-align:center">netctl</td><td style="text-align:center">2 unofficial</td><td style="text-align:center">netctl, wifi-menu</td><td style="text-align:center">Yes</td><td style="text-align:center">dhcpcd or dhclient</td><td style="text-align:center"><code>netctl-ifplugd@*interface*.service</code>, <code>netctl-auto@*interface*.service</code></td></tr><tr><td style="text-align:center">NetworkManager</td><td style="text-align:center">Yes</td><td style="text-align:center">nmcli, nmtui</td><td style="text-align:center">Yes</td><td style="text-align:center">internal or dhclient</td><td style="text-align:center"><code>NetworkManager.service</code></td></tr><tr><td style="text-align:center">systemd-networkd</td><td style="text-align:center">No</td><td style="text-align:center">networkctl</td><td style="text-align:center">No</td><td style="text-align:center">internal</td><td style="text-align:center"><code>systemd-networkd.service</code>, <code>systemd-resolved.service</code></td></tr></tbody></table><h3 id="NetworkManager">NetworkManager</h3><p><a href="https://networkmanager.dev/">NetworkManager</a> 是一个为系统提供检测和配置功能以便自动连接到网络的程序。支持 PPPoE 拨号，集成了 DHCP 服务。nmcli 是配置网络的命令行工具，nmtui 提供一个图形化文本界面来与NetworkManager交互用于配置网络。</p><h2 id="本机地址">本机地址</h2><h3 id="Hostname">Hostname</h3><p>在网络中，hostname 是一个分配给主机的一个域名，通常是一个主机的本地名字加上可选的域名，用点（.）分隔，例如 <a href="http://en.wikipedia.org">en.wikipedia.org</a>（主机名：en，域名：<a href="http://wikipedia.org">wikipedia.org</a>），这种主机名通过本机 hosts 文件或者 DNS 服务器解析为 IP 地址。一个主机可以拥有多个主机名。</p><p>可以通过修改 /etc/hostname 文件配置主机名，该文件包含单独的一行 <em>myhostname</em>，或者通过命令更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl set-hostname myhostname  <span class="comment"># 等同于修改 /etc/hostname</span></span><br><span class="line">hostname myhostname   <span class="comment"># 临时更改，重启失效</span></span><br></pre></td></tr></table></figure><p>要使你的设备能在局域网中被识别，有以下两种方法：</p><ol><li>在局域网上编辑每一台主机的 /etc/hosts 文件，加上你的主机；</li><li>配置一个 DNS 服务器，解析域名。</li></ol><h3 id="Hosts">Hosts</h3><p>Hosts 文件位于 /etc/hosts，以表的形式存储了主机名和 IP 地址的映射关系。Hosts文件是大多数系统都存在的一个小型主机表。Hosts文件中包含了本地网络重要的主机名和地址信息，查询Hosts文件得到的结果比通过查询 DNS 得到的结果优先级更高。</p><h3 id="Localhost">Localhost</h3><p>localhost 是一个在计算机网络中用于表示“此计算机”的主机名，它被用于通过本地回环网络接口，来访问本机运行的服务，并且将会绕过任何物理网络接口硬件。运用本地环回机制，便可在主机上运行网络服务，期间不须安装实体网络接口卡，也无须将该服务开放予主机所在网络。例如，在设置好本地安装的网站后，可通过<a href="http://xn--localhost-375n672fx23i35xb">http://localhost这一网址</a>，来访问本地网站。localhost这个主机名称一般会解析为 IPv4 本地回环地址 127.0.0.1 和 IPv6 本地回环地址 [::1].</p><p>为了解析本机主机名，可在 /etc/hosts 中添加以下信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1        localhost</span><br><span class="line">::1              localhost</span><br><span class="line">127.0.1.1        myhostname</span><br></pre></td></tr></table></figure><p>如果本机有一个永久的 IP 地址，则可配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1        localhost</span><br><span class="line">::1              localhost</span><br><span class="line">203.0.113.45     host1.fqdomain.example host1</span><br></pre></td></tr></table></figure><p>一般情况下本机有三块网卡：</p><ol><li>lo：回环网卡（Loopback Adapter），是一块虚拟网卡；</li><li>eth0：有线以太网卡；</li><li>wl0：WIFI无线网卡。</li></ol><p>localhost、127.0.0.1、0.0.0.0和本机IP的区别：</p><ol><li>localhost 是一个指向本机的域名，通过<a href="http://xn--localhost-375n672fx23i35xb">http://localhost这一网址</a>，来访问本地网站，localhost 指向的 IP 地址是可以配置的。不联网，不使用网卡，不受防火墙和网卡限制，本机访问。</li><li>127.0.0.1 是一个回环地址（Loop back address），通常分配给 loopback 接口。凡是以 127 开头的 IP 地址，都是回环地址，都指向 lo 网卡。发送给 127 开头的 IP 地址的数据包会被发送的主机自己接收，根本传不出去，外部设备也无法通过回环地址访问到本机。不联网，网卡传输，受防火墙和网卡限制，本机访问。</li><li>0.0.0.0是不能被 ping 通的，0.0.0.0称为“unspecified”，即未指定（即无效的，无意义的）地址。DHCP客户端还未获取到ip的时候规定使用0.0.0.0作“源地址”；在服务器中，0.0.0.0并不是一个真实的的IP地址，它表示本机中所有的IPV4地址。监听0.0.0.0的端口，就是监听本机中所有IP的端口。</li><li>本机IP通常仅指在同一个局域网内，能同时被外部设备访问和本机访问的那些IP地址（可能不止一个）。像127.0.0.1这种一般是不被当作本机IP的。本机IP是与具体的网络接口绑定的，比如以太网卡、无线网卡或者PPP/PPPoE拨号网络的虚拟网卡，想要正常工作都要绑定一个地址，否则其他设备就不知道如何访问它。联网，网卡传输，受防火墙和网卡限制，本机或外部访问。</li></ol><h2 id="参考文献">参考文献</h2><p>[1] <a href="https://wiki.archlinux.org/title/Network_configuration">Network_configuration</a><br>[2] <a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/PPPoE.html">什么是PPPoE？PPPoE解决了哪些问题？</a><br>[3] <a href="https://www.cnblogs.com/absoluteli/p/13958072.html">localhost、127.0.0.1和0.0.0.0和本机IP的区别</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 网络配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX 伪代码</title>
      <link href="/2022/10/23/LaTeX-pseudocode/"/>
      <url>/2022/10/23/LaTeX-pseudocode/</url>
      
        <content type="html"><![CDATA[<h1>LaTeX伪代码</h1><h2 id="介绍">介绍</h2><p>在LaTeX中排版算法或者伪代码有以下几种选择：</p><ul><li>使用algorithm包并选择algpseudocode OR compatible OR algorithmic其中一个包排版算法体。</li><li>使用algorithm与algorithmicx包并选择algpseudocode OR algcompatible OR  algpascal OR algc其中一个包排版算法。</li><li>使用algorithm2e包排版算法。</li></ul><p>注意:上述不同组包不可混用，否则编译会出错。</p><h3 id="algorithms包">algorithms包</h3><p><a href="http://mirror.ox.ac.uk/sites/ctan.org/macros/latex/contrib/algorithms/algorithms.pdf">algorithms使用文档.</a></p><blockquote><p>The <strong>algorithms</strong> package provides two environments, <strong>algorithmic</strong> and <strong>algorithm</strong>, which are designed to be used together but may, depending on the necessities of the user, be used separately.</p><p>The algorithmic environment provides an environment for describing algorithms and the algorithm environment provides a “float” wrapper for algorithms (implemented using algorithmic or some other method at the users’s option). The reason for two environments being provided is to allow the user maximum flexibility</p></blockquote><p>algorithms包提供了两种环境<strong>algorithm</strong> 与 <strong>algorithm</strong>.</p><h4 id="algorithm">algorithm</h4><p>algorithm是算法的<strong>float warpper</strong>，类似于table,  figure这样的们命令，使算法部分成为一个浮动体，防止它被分成两页。其官方介绍如下：</p><p>用法如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;algorithm&#125;</span><br><span class="line">    <span class="keyword">\caption</span>&#123;Algorithm caption&#125;</span><br><span class="line">    <span class="keyword">\label</span>&#123;alg:algorithm-label&#125;</span><br><span class="line">    <span class="keyword">\begin</span>&#123;algorithmic&#125;</span><br><span class="line">        ... Your pseudocode ...</span><br><span class="line">    <span class="keyword">\end</span>&#123;algorithmic&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;algorithm&#125;</span><br></pre></td></tr></table></figure><h4 id="algorithmic">algorithmic</h4><p>algorithm用于描述算法体。包含的基本命令如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\STATE</span> &lt;text&gt;</span><br><span class="line"><span class="keyword">\IF</span>&#123;&lt;condition&gt;&#125; <span class="keyword">\STATE</span> &#123;&lt;text&gt;&#125; <span class="keyword">\ELSE</span> <span class="keyword">\STATE</span>&#123;&lt;text&gt;&#125; <span class="keyword">\ENDIF</span></span><br><span class="line"><span class="keyword">\IF</span>&#123;&lt;condition&gt;&#125; <span class="keyword">\STATE</span> &#123;&lt;text&gt;&#125; <span class="keyword">\ELSIF</span>&#123;&lt;condition&gt;&#125; <span class="keyword">\STATE</span>&#123;&lt;text&gt;&#125; <span class="keyword">\ENDIF</span></span><br><span class="line"><span class="keyword">\FOR</span>&#123;&lt;condition&gt;&#125; <span class="keyword">\STATE</span> &#123;&lt;text&gt;&#125; <span class="keyword">\ENDFOR</span></span><br><span class="line"><span class="keyword">\FOR</span>&#123;&lt;condition&gt; <span class="keyword">\TO</span> &lt;condition&gt; &#125; <span class="keyword">\STATE</span> &#123;&lt;text&gt;&#125; <span class="keyword">\ENDFOR</span></span><br><span class="line"><span class="keyword">\FORALL</span>&#123;&lt;condition&gt;&#125; <span class="keyword">\STATE</span>&#123;&lt;text&gt;&#125; <span class="keyword">\ENDFOR</span></span><br><span class="line"><span class="keyword">\WHILE</span>&#123;&lt;condition&gt;&#125; <span class="keyword">\STATE</span>&#123;&lt;text&gt;&#125; <span class="keyword">\ENDWHILE</span></span><br><span class="line"><span class="keyword">\REPEAT</span> <span class="keyword">\STATE</span>&#123;&lt;text&gt;&#125; <span class="keyword">\UNTIL</span>&#123;&lt;condition&gt;&#125;</span><br><span class="line"><span class="keyword">\LOOP</span> <span class="keyword">\STATE</span>&#123;&lt;text&gt;&#125; <span class="keyword">\ENDLOOP</span></span><br><span class="line"><span class="keyword">\REQUIRE</span> &lt;text&gt;</span><br><span class="line"><span class="keyword">\ENSURE</span> &lt;text&gt;</span><br><span class="line"><span class="keyword">\RETURN</span> &lt;text&gt;</span><br><span class="line"><span class="keyword">\PRINT</span> &lt;text&gt;</span><br><span class="line"><span class="keyword">\COMMENT</span>&#123;&lt;text&gt;&#125;</span><br><span class="line"><span class="keyword">\AND</span>, <span class="keyword">\OR</span>, <span class="keyword">\XOR</span>, <span class="keyword">\NOT</span>, <span class="keyword">\TO</span>, <span class="keyword">\TRUE</span>, <span class="keyword">\FALSE</span></span><br></pre></td></tr></table></figure><p>注意：LaTeX中的命令区分大小写，algorithmic包中命令都是全大写。</p><p>为了适应不同语言，所有的关键字输出形式都可以重定义，例如：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\floatname</span>&#123;algorithm&#125;&#123;Procedure&#125;</span><br><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\algorithmicrequire</span>&#125;&#123;<span class="keyword">\textbf</span>&#123;Input:&#125;&#125;</span><br><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\algorithmicensure</span>&#125;&#123;<span class="keyword">\textbf</span>&#123;Output:&#125;&#125;</span><br></pre></td></tr></table></figure><p>algorithmic包没有提供函数关键字的支持。</p><h3 id="algorithmicx">algorithmicx</h3><p><a href="https://mirrors.harcombe.net/tex-archive/macros/latex/contrib/algorithmicx/algorithmicx.pdf">algorithmicx使用文档.</a></p><blockquote><p>The package algorithmicx itself doesn’t define any algorithmic commands, but gives a set of macros to define such a command set. You may use only algorithmicx, and define the commands yourself, or you may use one of the predefined command sets.</p><p>These predefined command sets (layouts) are:</p><p><strong>algpseudocode</strong> has the same look1 as the one defined in the algorithmic package. The main difference is that while the algorithmic package doesn’t allow you to modify predefined structures, or to create new ones, the algorithmicx package gives you full control over the definitions (ok, there are some limitations — you can not send mail with a, say, \For command).</p><p><strong>algcompatible</strong> is fully compatible with the algorithmic package, it should be used only in old documents.</p><p><strong>algpascal</strong> aims to create a formatted pascal program, it performs automatic indentation (!), so you can transform a pascal program into an algpascal algorithm description with some basic substitution rules.</p><p><strong>algc</strong> – yeah, just like the algpascal. . . but for c. . . This layout is incomplete.</p><p>To create floating algorithms you will need algorithm.sty. This file may or may not be included in the algorithmicx package. You can find it on CTAN, in the algorithmic package</p></blockquote><p>algorithmicx包本身没有定义任何algorithmic命令，但是给了一些宏去定义这样的命令，使用algorithmicx包时可以选择自定义命令或者自定义区块，另外algorithmicx包预定义了一些命令集，如algpseudocode、algcompatible、algpascal、algc，这些命令集中的命令也可以修改。一般algpseudocode使用的比较多。</p><h4 id="algpseudocode">algpseudocode</h4><p>基础命令如下：</p><p>Statement (\State 会换行，可以用在其他命令之前)</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\State</span> <span class="built_in">$</span>x<span class="keyword">\gets</span> &lt;value&gt;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>三种 if-statements:</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\If</span>&#123;&lt;condition&gt;&#125; &lt;text&gt; <span class="keyword">\EndIf</span></span><br><span class="line"><span class="keyword">\If</span>&#123;&lt;condition&gt;&#125; &lt;text&gt; <span class="keyword">\Else</span> &lt;text&gt; <span class="keyword">\EndIf</span></span><br><span class="line"><span class="keyword">\If</span>&#123;&lt;condition&gt;&#125; &lt;text&gt; <span class="keyword">\ElsIf</span>&#123;&lt;condition&gt;&#125; &lt;text&gt; <span class="keyword">\Else</span> &lt;text&gt; <span class="keyword">\EndIf</span></span><br></pre></td></tr></table></figure><p>Loops:</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\For</span>&#123;&lt;condition&gt;&#125; &lt;text&gt; <span class="keyword">\EndFor</span></span><br><span class="line"><span class="keyword">\ForAll</span>&#123;&lt;condition&gt;&#125; &lt;text&gt; <span class="keyword">\EndFor</span></span><br><span class="line"><span class="keyword">\While</span>&#123;&lt;condition&gt;&#125; &lt;text&gt; <span class="keyword">\EndWhile</span></span><br><span class="line"><span class="keyword">\Repeat</span> &lt;text&gt; <span class="keyword">\Until</span>&#123;&lt;condition&gt;&#125;</span><br><span class="line"><span class="keyword">\Loop</span> &lt;text&gt; <span class="keyword">\EndLoop</span></span><br></pre></td></tr></table></figure><p>Pre- and postcondition:</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\Require</span> &lt;text&gt;</span><br><span class="line"><span class="keyword">\Ensure</span> &lt;text&gt;</span><br></pre></td></tr></table></figure><p>Functions</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\Function</span>&#123;&lt;name&gt;&#125;&#123;&lt;params&gt;&#125; &lt;body&gt; <span class="keyword">\EndFunction</span></span><br><span class="line"><span class="keyword">\Return</span> &lt;text&gt;</span><br><span class="line"><span class="keyword">\Call</span>&#123;&lt;name&gt;&#125;&#123;&lt;params&gt;&#125;</span><br></pre></td></tr></table></figure><p>Comments:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\Comment&#123;&lt;text&gt;&#125;</span><br></pre></td></tr></table></figure><p>注意：algorithmicx包中命令为只有首字母大写，且定义了函数语句。</p><p>示例：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;algorithm&#125;</span><br><span class="line">    <span class="keyword">\caption</span>&#123;Euclid’s algorithm&#125;<span class="keyword">\label</span>&#123;euclid&#125;</span><br><span class="line">    <span class="keyword">\begin</span>&#123;algorithmic&#125;[1]</span><br><span class="line">    <span class="keyword">\Function</span>&#123;Euclid&#125;&#123;<span class="built_in">$</span>a,b<span class="built_in">$</span>&#125;<span class="keyword">\Comment</span>&#123;The g.c.d. of a and b&#125;</span><br><span class="line">    <span class="keyword">\State</span> <span class="built_in">$</span>r<span class="keyword">\gets</span> a<span class="keyword">\bmod</span> b<span class="built_in">$</span></span><br><span class="line">    <span class="keyword">\While</span>&#123;<span class="built_in">$</span>r<span class="keyword">\not</span>=0<span class="built_in">$</span>&#125;<span class="keyword">\Comment</span>&#123;We have the answer if r is 0&#125;</span><br><span class="line">    <span class="keyword">\State</span> <span class="built_in">$</span>a<span class="keyword">\gets</span> b<span class="built_in">$</span></span><br><span class="line">    <span class="keyword">\State</span> <span class="built_in">$</span>b<span class="keyword">\gets</span> r<span class="built_in">$</span></span><br><span class="line">    <span class="keyword">\State</span> <span class="built_in">$</span>r<span class="keyword">\gets</span> a<span class="keyword">\bmod</span> b<span class="built_in">$</span></span><br><span class="line">    <span class="keyword">\EndWhile</span><span class="keyword">\label</span>&#123;euclidendwhile&#125;</span><br><span class="line">    <span class="keyword">\State</span> <span class="keyword">\textbf</span>&#123;return&#125; <span class="built_in">$</span>b<span class="built_in">$</span><span class="keyword">\Comment</span>&#123;The gcd is b&#125;</span><br><span class="line">    <span class="keyword">\EndFunction</span></span><br><span class="line">    <span class="keyword">\end</span>&#123;algorithmic&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;algorithm&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/img/latex/al1.PNG" alt=""></p><h3 id="algpseudocodex">algpseudocodex</h3><p><a href="https://mirror.apps.cam.ac.uk/pub/tex-archive/macros/latex/contrib/algpseudocodex/algpseudocodex.pdf">algpseudocodex使用文档.</a></p><p>algpseudocodex包的基本使用与algorithmicx包中的algpseudocode相同。</p><h3 id="algorithm2e">algorithm2e</h3><p><a href="https://mirror.ox.ac.uk/sites/ctan.org/macros/latex/contrib/algorithm2e/doc/algorithm2e.pdf">algorithm2e使用文档.</a></p><p>algorithm2e 包允许大量自定义排版算法。与 algorithmic 不同，algorithm2e 为算法提供了很多的定制选项，以适应各种用户的需求。 通常，\begin{algorithm} 和 \end{algorithm} 之间的用法是</p><ol><li>Declaring a set of keywords(to typeset as functions/operators), layout controls, caption, title, header text (which appears before the algorithm’s main steps e.g.: Input,Output)</li><li>Writing the main steps of the algorithm, with each step ending with a ;<br>This may be taken in analogy with writing a latex-preamble before we start the actual document.</li></ol><p>包加载如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>[options]&#123;algorithm2e&#125;</span><br></pre></td></tr></table></figure><p>可选参数options有[Hhtbp]，使用H参数算法排版不再是浮动体，如果空间不足，前后会留出空白。</p><p>用法示例：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>&#123;article&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\usepackage</span>[ruled, vlined, linesnumbered]&#123;algorithm2e&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;algorithm&#125;[t]</span><br><span class="line">    <span class="keyword">\caption</span>&#123;How to write algorithms&#125;</span><br><span class="line">    <span class="keyword">\begin</span>&#123;small&#125;</span><br><span class="line">        <span class="keyword">\BlankLine</span></span><br><span class="line">        <span class="keyword">\KwData</span>&#123;this text&#125;</span><br><span class="line">        <span class="keyword">\KwResult</span>&#123;how to write algorithm with <span class="keyword">\LaTeX</span>2e &#125;</span><br><span class="line">        initialization<span class="keyword">\;</span></span><br><span class="line">        <span class="keyword">\While</span>&#123;not at end of this document&#125;&#123;</span><br><span class="line">        read current<span class="keyword">\;</span></span><br><span class="line">        <span class="keyword">\eIf</span>&#123;understand&#125;&#123;</span><br><span class="line">        go to next section<span class="keyword">\;</span></span><br><span class="line">        current section becomes this one<span class="keyword">\;</span></span><br><span class="line">        &#125;&#123;</span><br><span class="line">        go back to the beginning of current section<span class="keyword">\;</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">\end</span>&#123;small&#125;       </span><br><span class="line"><span class="keyword">\end</span>&#123;algorithm&#125; </span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/img/latex/al2.PNG" alt=""></p><h2 id="算法跨页展示">算法跨页展示</h2><p>上述方式无论是将算法体设置为浮动体还是设置为固定位置，有时候会排版不佳，有些包中也提供跨页的解决方法。这里提供另一种方式，在引言区定义新环境breakablealgorithm：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\makeatletter</span></span><br><span class="line"><span class="keyword">\newenvironment</span>&#123;breakablealgorithm&#125;</span><br><span class="line">  &#123;<span class="comment">% \begin&#123;breakablealgorithm&#125;</span></span><br><span class="line">   <span class="keyword">\begin</span>&#123;center&#125;</span><br><span class="line">     <span class="keyword">\refstepcounter</span>&#123;algorithm&#125;<span class="comment">% New algorithm</span></span><br><span class="line">     <span class="keyword">\hrule</span> height.8pt depth0pt <span class="keyword">\kern</span>2pt<span class="comment">% \@fs@pre for \@fs@ruled</span></span><br><span class="line">     <span class="keyword">\renewcommand</span>&#123;<span class="keyword">\caption</span>&#125;[2][<span class="keyword">\relax</span>]&#123;<span class="comment">% Make a new \caption</span></span><br><span class="line">       &#123;<span class="keyword">\raggedright</span><span class="keyword">\textbf</span>&#123;<span class="keyword">\fname@algorithm</span>~<span class="keyword">\thealgorithm</span>&#125; <span class="params">##2</span><span class="keyword">\par</span>&#125;<span class="comment">%</span></span><br><span class="line">       <span class="keyword">\ifx</span><span class="keyword">\relax</span><span class="params">##1</span><span class="keyword">\relax</span> <span class="comment">% #1 is \relax</span></span><br><span class="line">         <span class="keyword">\addcontentsline</span>&#123;loa&#125;&#123;algorithm&#125;&#123;<span class="keyword">\protect</span><span class="keyword">\numberline</span>&#123;<span class="keyword">\thealgorithm</span>&#125;<span class="params">##2</span>&#125;<span class="comment">%</span></span><br><span class="line">       <span class="keyword">\else</span> <span class="comment">% #1 is not \relax</span></span><br><span class="line">         <span class="keyword">\addcontentsline</span>&#123;loa&#125;&#123;algorithm&#125;&#123;<span class="keyword">\protect</span><span class="keyword">\numberline</span>&#123;<span class="keyword">\thealgorithm</span>&#125;<span class="params">##1</span>&#125;<span class="comment">%</span></span><br><span class="line">       <span class="keyword">\fi</span></span><br><span class="line">       <span class="keyword">\kern</span>2pt<span class="keyword">\hrule</span><span class="keyword">\kern</span>2pt</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;&#123;<span class="comment">% \end&#123;breakablealgorithm&#125;</span></span><br><span class="line">     <span class="keyword">\kern</span>2pt<span class="keyword">\hrule</span><span class="keyword">\relax</span><span class="comment">% \@fs@post for \@fs@ruled</span></span><br><span class="line">   <span class="keyword">\end</span>&#123;center&#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">\makeatother</span></span><br></pre></td></tr></table></figure><p>将algorithm环境替换为breakablealgorithm环境即可，即为：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;breakablealgorithm&#125;</span><br><span class="line">    <span class="keyword">\caption</span>&#123;Algorithm caption&#125;</span><br><span class="line">    <span class="keyword">\label</span>&#123;alg:algorithm-label&#125;</span><br><span class="line">    <span class="keyword">\begin</span>&#123;algorithmic&#125;</span><br><span class="line">        ... Your pseudocode ...</span><br><span class="line">    <span class="keyword">\end</span>&#123;algorithmic&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;breakablealgorithm&#125;</span><br></pre></td></tr></table></figure><p>更多内容参见包手册。</p><h2 id="参考文献">参考文献</h2><p>[1] <a href="https://en.wikibooks.org/wiki/LaTeX/Algorithms#Typesetting_using_the_algorithmic_package">wikibooks LaTeX/Algorithms</a></p><p>[2] <a href="https://tex.stackexchange.com/questions/33866/algorithm-tag-and-page-break">Algorithm tag and page break</a></p>]]></content>
      
      
      <categories>
          
          <category> LaTeX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建教程</title>
      <link href="/2022/10/22/blog-building-tutorial/"/>
      <url>/2022/10/22/blog-building-tutorial/</url>
      
        <content type="html"><![CDATA[<h1>博客搭建教程</h1><p>本教程基于 Hexo 框架 + Butterfly 主题 + GitHub Pages 搭建博客</p><h2 id="环境准备">环境准备</h2><ul><li>安装 <a href="http://nodejs.org/">Node.js</a></li><li><a href="http://git-scm.com/">Git</a></li></ul><h2 id="搭建步骤">搭建步骤</h2><h3 id="安装-Hexo">安装 Hexo</h3><p><a href="https://hexo.io/zh-cn/docs/">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;    <span class="comment"># 初始化Hexo项目文件夹</span></span><br><span class="line"><span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">npm install           <span class="comment"># 安装项目依赖</span></span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml      # 网站的配置信息</span><br><span class="line">├── package.json     # 应用程序的信息</span><br><span class="line">├── scaffolds        # 模版文件夹,当新建文章时，Hexo会根据scaffold来建立文件</span><br><span class="line">├── source           # 存放用户资源的地方</span><br><span class="line">|   ├── _drafts      # 存放drafts文档</span><br><span class="line">|   └── _posts       # 存放posts文档</span><br><span class="line">└── themes           # 主题文件夹</span><br></pre></td></tr></table></figure><h3 id="主题">主题</h3><p><a href="https://butterfly.js.org/">hexo-theme-butterfly</a>是基于 hexo-theme-melody 的基础上进行开发的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-theme-butterfly</span><br><span class="line">npm update hexo-theme-butterfly  <span class="comment"># 升级命令</span></span><br></pre></td></tr></table></figure><p>修改 Hexo 根目录下的 _config.yml，把主题改为butterfly</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure><p>下载安装pug 以及 stylus 的渲染器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><p>在 hexo 的根目录创建一个文件 _config.butterfly.yml，并把主题目录的 <a href="https://github.com/jerryc127/hexo-theme-butterfly">_config.yml</a> 内容复製到 _config.butterfly.yml 去，在 _config.butterfly.yml 更改主题配置。</p><h3 id="部署">部署</h3><p>在本教程中，我们将会使用 <a href="https://travis-ci.com/">Travis CI</a> 将 Hexo 博客部署到 GitHub Pages 上。Travis CI 对于开源 repository 是免费的，但是这意味着你的站点文件将会是公开的。</p><ol><li><p>新建一个 repository。如果你希望你的站点能通过域名 <code>&lt;你的 GitHub 用户名&gt;.github.io</code> 访问，你的 repository 应该直接命名为 <code>&lt;你的 GitHub 用户名&gt;.github.io</code>。</p></li><li><p>将你的 Hexo 站点文件夹推送到 repository 中。默认情况下 <code>public</code> 目录将不会（也不应该）被推送到 repository 中，你应该检查 <code>.gitignore</code> 文件中是否包含 <code>public</code> 一行，如果没有请加上。</p></li><li><p>将 <a href="https://github.com/marketplace/travis-ci">Travis CI</a> 添加到你的 GitHub 账户中。</p></li><li><p>前往 GitHub 的 <a href="https://github.com/settings/installations">Applications settings</a>，配置 Travis CI 权限，使其能够访问你的 repository。</p></li><li><p>你应该会被重定向到 Travis CI 的页面。如果没有，请 <a href="https://travis-ci.com/">手动前往</a>。</p></li><li><p>在浏览器内新建一个标签页，前往 GitHub <a href="https://github.com/settings/tokens">新建 Personal Access Token</a>，只勾选 <code>repo</code> 的权限并生成一个新的 Token。Token 生成后请复制并保存好。</p></li><li><p>回到 Travis CI，前往你的 repository 的设置页面，在 <strong>Environment Variables</strong> 下新建一个环境变量，<strong>Name</strong> 为 <code>GH_TOKEN</code>，<strong>Value</strong> 为刚才你在 GitHub 生成的 Token。确保 <strong>DISPLAY VALUE IN BUILD LOG</strong> 保持 <strong>不被勾选</strong> 避免你的 Token 泄漏。点击 <strong>Add</strong> 保存。</p></li><li><p>在你的 Hexo 站点文件夹中新建一个 <code>.travis.yml</code> 文件：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sudo:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10</span> <span class="comment"># use nodejs v10 LTS</span></span><br><span class="line"><span class="attr">cache:</span> <span class="string">npm</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span> <span class="comment"># build master branch only</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">generate</span> <span class="comment"># generate static files</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">pages</span></span><br><span class="line">  <span class="attr">skip-cleanup:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">github-token:</span> <span class="string">$GH_TOKEN</span></span><br><span class="line">  <span class="attr">keep-history:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">on:</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">local-dir:</span> <span class="string">public</span></span><br></pre></td></tr></table></figure></li><li><p>将 <code>.travis.yml</code> 推送到 repository 中。Travis CI 应该会自动开始运行，并将生成的文件推送到同一 repository 下的 <code>gh-pages</code> 分支下。</p></li><li><p>在 GitHub 中前往你的 repository 的设置页面，修改 <code>GitHub Pages</code> 的部署分支为 <code>gh-pages</code>。</p></li><li><p>前往 <code>https://&lt;你的 GitHub 用户名&gt;.github.io</code> 查看你的站点是否可以访问。这可能需要一些时间。</p></li></ol><p><strong>注意</strong>：</p><p>Travis CI 提供的是持续集成服务（Continuous Integration，简称 CI）。它绑定 Github 上面的项目，只要有新的代码，就会自动抓取。然后，提供一个运行环境，执行测试，完成构建，还能部署到服务器。这个步骤不是必须的。</p><h4 id="一键部署">一键部署</h4><ol><li>安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ol><li>修改配置。</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">&lt;repository</span> <span class="string">url&gt;</span> <span class="comment">#https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io</span></span><br><span class="line">  <span class="attr">branch:</span> [<span class="string">branch</span>]</span><br><span class="line">  <span class="attr">message:</span> [<span class="string">message</span>]</span><br><span class="line">  <span class="attr">token:</span> [<span class="string">token</span>]</span><br></pre></td></tr></table></figure><p>token是部署中第6步产生的token，用于访问仓库，否则需要配置账号与密码。</p><p>由于 Hexo 的部署默认使用分支 <code>master</code>，所以如果你同时正在使用 Git 管理你的站点目录，你应当注意你的部署分支应当不同于写作分支。一个好的实践是将站点目录和 Pages 分别存放在两个不同的 Git 仓库中，可以有效避免相互覆盖。Hexo 在部署你的站点生成的文件时并不会更新你的站点目录。因此你应该手动提交并推送你的写作分支。修改上述branch为站点目录分支，同时需要修改仓库的部署分支。</p><ol start="3"><li><p>Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></li></ol><h2 id="目录结构">目录结构</h2><p><strong>source</strong> 目录用户资源文件，是项目的根文件 / ，所有文章、页面、图片、音视频等资源都放在该目录下，应用该目录下的文件，文件路径从根目录 / 开始。</p><p><strong>scaffolds</strong> 目录存放模版文件，当新建文章时，Hexo会根据scaffold来建立文件。</p><p>Hexo 有三种默认布局（模版）：<code>post</code>、<code>page</code> 和 <code>draft</code>。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。</p><table><thead><tr><th style="text-align:left">布局</th><th style="text-align:left">路径</th></tr></thead><tbody><tr><td style="text-align:left"><code>post</code></td><td style="text-align:left"><code>source/_posts</code></td></tr><tr><td style="text-align:left"><code>page</code></td><td style="text-align:left"><code>source</code></td></tr><tr><td style="text-align:left"><code>draft</code></td><td style="text-align:left"><code>source/_drafts</code></td></tr></tbody></table><p><strong>public</strong> 目录是Hexo框架根据源文件产生的静态网站文件，部署时，需要将 <strong>public</strong> 目录中的所有内容上传到网站。</p><h2 id="博客写作">博客写作</h2><p>执行下列命令来创建一篇新文章或者新的页面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>可以在命令中指定文章的布局（layout），默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p><p>通常 post 布局就是我们的博文模板，而 page 布局用来定义tags、categories、links、about等页面。</p><p>在 _config.butterfly.yml文件中定义菜单栏：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">首页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">目录||fas</span> <span class="attr">fa-list:</span></span><br><span class="line">    <span class="string">时间轴:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">    <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">    <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">  <span class="string">链接:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line">  <span class="string">关于:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-heart</span></span><br></pre></td></tr></table></figure><p>需要定义相应的 page 页面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p>接下来修改生成的 <a href="http://index.md">index.md</a> 文件中的类型（type）：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2022-10-22 18:46:11</span><br><span class="line"><span class="section">type: tags</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><h2 id="部署-2">部署</h2><p>运行下述命令生成网站静态文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean    <span class="comment"># 清理之前生成的文件</span></span><br><span class="line">hexo g        <span class="comment"># 生成网站静态文件</span></span><br><span class="line">hexo d        <span class="comment"># 配置了部署信息则运行该命令，否则手动部署</span></span><br><span class="line">hexo s        <span class="comment"># 本地测试生成的网站文件</span></span><br></pre></td></tr></table></figure><h2 id="插件">插件</h2><h3 id="搜索功能">搜索功能</h3><ol><li><p>安装依赖。<br>前往博客根目录，打开cmd命令窗口执行<code>npm install hexo-generator-search --save</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure></li><li><p>注入配置。<br>修改站点配置文件<code>_config.yml</code>，添加如下代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">template:</span> <span class="string">./search.xml</span></span><br></pre></td></tr></table></figure></li><li><p>主题中开启搜索。<br>在主题配置文件<code>_config.butterfly.yml</code>中修改以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="使用-LaTex-公式">使用 LaTex 公式</h3><p>Hexo 博客使用 LaTeX 公式有两种方法： MathJax 和 KaTeX 。其中 MathJax 功能多，但渲染时间长，且效果不如 KaTeX 。两种方法只能用一种，推荐用 KaTeX 。</p><p>Butterfly 中使用 KaTeX 步骤如下：</p><ol><li><p>更换插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save <span class="comment"># 卸载 marked 插件</span></span><br><span class="line">npm un hexo-renderer-kramed --save <span class="comment"># 卸载 kramed 插件</span></span><br><span class="line">npm i hexo-renderer-markdown-it --save <span class="comment"># 安装渲染插件</span></span><br><span class="line">npm install @neilsustc/markdown-it-katex --save <span class="comment"># 安装katex插件</span></span><br></pre></td></tr></table></figure></li><li><p>修改主题配置文件 <code>_config.butterfly.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># KaTeX</span></span><br><span class="line"><span class="attr">katex:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">hide_scrollbar:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>在博客配置文件 <code>_config.yml</code> 中追加代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">markdown:</span></span><br><span class="line"> <span class="attr">plugins:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">plugin:</span></span><br><span class="line">     <span class="attr">name:</span> <span class="string">&#x27;@neilsustc/markdown-it-katex&#x27;</span></span><br><span class="line">     <span class="attr">options:</span></span><br><span class="line">       <span class="attr">strict:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ol><p>配置成功后，需要渲染的文章开头，添加参数 <code>katex: true</code> 即可。</p><blockquote><p>方法缺陷：插件 <code>hexo-renderer-markdown-it</code> 在渲染的文章，一级目录无法跳转。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven自动化的构建工具</title>
      <link href="/2022/03/20/java-packagemanager-maven/"/>
      <url>/2022/03/20/java-packagemanager-maven/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是Maven">什么是Maven</h3><p>Maven是Apache基金会的开源项目，使用Java语法开发，Maven是项目的自动化构建工具，管理项目的依赖。</p><p>类似的构建工具还有：Ant，Gradle</p><h3 id="Maven能做什么">Maven能做什么</h3><p>（1）项目的自动构建，帮助开发人员做项目代码的编译、测试、打包、安装、部署等工作；</p><p>（2）管理依赖</p><p>依赖：项目中需要使用的其他资源，常见的是jar；<br>备注：没有Maven时，管理jar，需要从网络中单独下载，需要选择正确版本， 手工处理jar文件之间的依赖</p><h3 id="Maven中的概念">Maven中的概念</h3><h4 id="约定的目录结构">约定的目录结构</h4><table><thead><tr><th>目录</th><th>目的</th></tr></thead><tbody><tr><td>${basedir}</td><td>存放 pom.xml 和所有的子目录</td></tr><tr><td>${basedir}/src/main/java</td><td>项目的 Java 源代码</td></tr><tr><td>${basedir}/src/main/resources</td><td>项目的资源，比如说 property 文件，springmvc.xml</td></tr><tr><td>${basedir}/src/test/java</td><td>项目的测试类，比如说 Junit 代码</td></tr><tr><td>${basedir}/src/test/resources</td><td>测试用的资源</td></tr><tr><td>${basedir}/src/main/webapp/WEB_INF</td><td>web 应用文件目录，web 的项目信息，比如存放 web.xml、本地图片、jsp 视图页面</td></tr><tr><td>${basedir}/target</td><td>打包输出目录</td></tr><tr><td>${basedir}/target/classes</td><td>编译输出目录</td></tr><tr><td>${basedir}/target/test-classes</td><td>测试编译输出目录</td></tr><tr><td>Test.java</td><td>Maven 只会自动运行符合该命名规则的测试类</td></tr><tr><td>~/.m2/repository</td><td>Maven 默认的本地仓库目录位置</td></tr></tbody></table><h4 id="配置文件">配置文件</h4><table><thead><tr><th>类型</th><th>在哪定义</th></tr></thead><tbody><tr><td>项目级（per Project）</td><td>定义在项目的 POM 文件 pom.xml 中</td></tr><tr><td>用户级（Per User）</td><td>定义在 Maven 的设置 xml 文件中（%USER_HOME%/.m2/settings.xml）</td></tr><tr><td>全局（Global）</td><td>定义在 Maven 的全局设置 xml 文件中（%MAVEN_HOME%/conf/settings.xml）</td></tr></tbody></table><h4 id="POM">POM</h4><p>Project Object Model项目对象模型，Maven把项目当做模型处理。<br>Maven通过pom.xml文件实现项目的构建和依赖的管理。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- project是根标签，后面是约束文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- POM模型的版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 坐标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>edu.stanford.cs.crypto<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>efficientct<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 打包类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- Maven常用设置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 设置构建项目的相关内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置插件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">source</span>&gt;</span><span class="comment">&lt;!-- 指定编译代码的jdk版本 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">target</span>&gt;</span><span class="comment">&lt;!-- 指定运行代码的jdk版本 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>sonatype-oss-snapshot<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://oss.sonatype.org/content/repositories/snapshots<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>project.local<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>project<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>file:$&#123;project.basedir&#125;/repo<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（1）坐标</p><p>坐标组成是 groupId  artifactId   version<br>坐标的作用：确定资源，是资源的唯一标识，简称gav</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>edu.stanford.cs.crypto<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> groupId：组织名称，组织域名倒写</span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>efficientct<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>      artifactId：项目名称</span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>           version：版本，项目的版本号，使用数字，例如1.0.3</span><br></pre></td></tr></table></figure><blockquote><p>备注：版本号中带-SNAPSHOT表示快照，为不稳定版本，Release 则代表稳定的版本。</p><p>项目中使用gav<br>1、每个Maven项目，都需要有一个自己的gav<br>2、管理依赖，需要使用其他jar，也需要使用gav作为标识</p></blockquote><p>（2）依赖管理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="仓库管理">仓库管理</h4><p>Maven仓库存放Maven工具jar包，第三方jar包，自己编写的jar包</p><p>仓库的分类：</p><p>1、本地（local）：<br>默认路径：C:\Users\Ivresse\.m2\repository</p><p>修改本地仓库位置，修改安装目录apache-maven-3.8.4\conf\settings.xml文件中<localRepository></localRepository>标签</p><p>2、中央（central）： Maven 社区提供的仓库<br>要浏览中央仓库的内容，maven 社区提供了一个 URL：<a href="http://search.maven.org/#browse">http://search.maven.org/#browse</a>，使用这个仓库，开发人员可以搜索所有可以获取的代码库，或者使用<a href="https://mvnrepository.com/">https://mvnrepository.com/</a>。<br>Maven 仓库默认在国外， 国内使用难免很慢，我们可以更换为阿里云的仓库，<a href="https://developer.aliyun.com/mvn/guide">配置指南</a>。<br>修改 maven 根目录下的 conf 文件夹中的 settings.xml 文件，在 mirrors 节点上，添加内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>阿里云公共仓库<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果想在项目中使用其它代理仓库，可在 <strong><repositories></repositories></strong> 节点中加入对应的仓库使用地址。以使用 spring 代理仓为例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/spring<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br></pre></td></tr></table></figure><p>全局配置则将上述配置写在<profile></profile>标签中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span>  </span><br><span class="line">  ...  </span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">      <span class="comment">&lt;!-- repositories and pluginRepositories here--&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span>  </span><br><span class="line">  ...  </span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span>  </span><br></pre></td></tr></table></figure><p>3、远程（remote）：开发人员自己定制仓库</p><p>当我们执行 Maven 构建命令时，Maven 开始按照以下顺序查找依赖的库：</p><ul><li><strong>步骤 1</strong> － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。</li><li><strong>步骤 2</strong> － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中以备将来引用。</li><li><strong>步骤 3</strong> － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。</li><li><strong>步骤 4</strong> － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库以备将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件）。</li></ul><h4 id="生命周期">生命周期</h4><p>项目构建的各个阶段，包括清理、编译、测试、打包、安装、部署。</p><h4 id="插件和命令">插件和命令</h4><p>要完成构建项目的各个阶段，要使用Maven命令，执行命令的功能是通过插件完成的，插件就是jar包，一些类。</p><h3 id="Maven命令">Maven命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mvn -v </span><br><span class="line"><span class="comment"># 查看Maven版本信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下命令在项目根目录下执行</span></span><br><span class="line">mvn clean</span><br><span class="line"><span class="comment"># 清理命令，删除以前生成的数据（删除target目录）</span></span><br><span class="line"><span class="comment"># 插件：maven-clean-plugin</span></span><br><span class="line">mvn compile    </span><br><span class="line"><span class="comment"># 编译命令，将src/main/java目录中的代码编译为class文件</span></span><br><span class="line"><span class="comment"># 把class文件拷贝到target/classes目录,这个目录classes是存放类文件的根目录（也叫类路径，classpath）</span></span><br><span class="line"><span class="comment"># 插件：maven-compiler-plugin</span></span><br><span class="line"><span class="comment"># 插件：maven-resources-plugin 资源插件，把src/main/resources目录中的文件拷贝到target/classes目录中</span></span><br><span class="line">mvn test-compile</span><br><span class="line"><span class="comment"># 编译命令，将src/test/java目录中的代码编译为class文件</span></span><br><span class="line"><span class="comment"># 把class文件拷贝到target/test-classes目录</span></span><br><span class="line"><span class="comment"># 把src/test/resources目录中的文件拷贝到target/taet-classes目录中</span></span><br><span class="line">mvn <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 测试命令，执行test-classes目录的程序，测试src/main/java目录中的主程序代码是否符合要求</span></span><br><span class="line"><span class="comment"># 插件：maven-surefire-plugin</span></span><br><span class="line">mvn package</span><br><span class="line"><span class="comment"># 打包，把项目中的资源class文件和配置文件都放到一个压缩文件中</span></span><br><span class="line"><span class="comment"># 默认压缩文件是jar类型的，web应用是war类型，扩展是jar，war的</span></span><br><span class="line"><span class="comment"># 插件：maven-jar-plugin 执行打包处理，生成文件在target目录下</span></span><br><span class="line"><span class="comment"># 打包文件名：artifactId-version.packaging</span></span><br><span class="line"><span class="comment"># 打包文件包含/src/main目录中的所有的生成的class和配置文件，与test无关</span></span><br><span class="line">mvn install</span><br><span class="line"><span class="comment"># 把生成的打包的文件安装到本地仓库</span></span><br><span class="line"><span class="comment"># 插件：maven-install-plugin</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机网络介绍</title>
      <link href="/2021/12/19/vmware-network/"/>
      <url>/2021/12/19/vmware-network/</url>
      
        <content type="html"><![CDATA[<p>Workstation Pro 中的虚拟网络连接组件包括虚拟交换机、虚拟网络适配器、虚拟 DHCP 服务器和 NAT 设备。</p><h3 id="虚拟交换机">虚拟交换机</h3><p>与物理交换机相似，虚拟交换机也能将网络连接组件连接在一起。虚拟交换机又称为虚拟网络，其名称为 VMnet0、VMnet1、VMnet2，以此类推。有少量虚拟交换机会默认映射到特定网络。</p><p>安装好VMware Workstation后，会在物理机中模拟出两个虚拟网卡。</p><p><img src="/img/linux/vmware_1.webp" alt="img"></p><h3 id="默认虚拟网络交换机">默认虚拟网络交换机</h3><table><thead><tr><th>网络类型</th><th>交换机名称</th></tr></thead><tbody><tr><td>桥接模式</td><td>VMnet0</td></tr><tr><td>NAT</td><td>VMnet8</td></tr><tr><td>仅主机模式</td><td>VMnet1</td></tr></tbody></table><h3 id="桥接模式-bridged">桥接模式(bridged)</h3><p>在这种模式下，使用VMnet0虚拟交换机，虚拟操作系统就像是局域网中的一台独立的主机，与宿主计算机一样，它可以访问网内任何一台机器。在桥接模式下，可以手工配置它的TCP/IP配置信息（IP、子网掩码等，而且还要和宿主机器处于同一网段），以实现通过局域网的网关或路由器访问互联网；还可以将IP地址和DNS设置成“自动获取”。</p><p>如果你想利用VMWare在局域网内新建一个服务器，为局域网用户提供Web或网络服务，就应该选择桥接模式。</p><p>在桥接模式中，使用VMnet0虚拟交换机，此时虚拟机相当与网络上的一台独立计算机与主机一样，拥有一个独立的IP地址。</p><p><img src="/img/linux/vmware_2.webp" alt="img"></p><h3 id="网络地址转换模式-NAT">网络地址转换模式(NAT)</h3><p>使用NAT模式，就是让虚拟机借助NAT（网络地址转换）功能，通过宿主机器所在的网络来访问公网。也就是说，使用NAT模式可以实现在虚拟系统里访问互联网。NAT模式下的虚拟机的TCP/IP配置信息是由VMnet8虚拟网络的DHCP服务器提供的，因此IP和DNS一般设置为“自动获取”，因此虚拟系统也就无法和本局域网中的其他真实主机进行通讯。</p><p>采用NAT模式最大的优势是虚拟系统接入互联网非常简单，你不需要进行任何其他的配置，只需要宿主机器能访问互联网即可。如果你想利用VMWare安装一个新的虚拟系统，在虚拟系统中不用进行任何手工配置就能直接访问互联网，建议你采用NAT模式。</p><p>NAT模式中，此时虚拟机可以通过主机“单向访问”网络上的其他主机，其他主机不能访问虚拟机。在NAT模式中：</p><p><img src="/img/linux/vmware_3.webp" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VMWare </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么选择Arch Linux</title>
      <link href="/2021/12/18/why-use-archlinux/"/>
      <url>/2021/12/18/why-use-archlinux/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>之前因为要学习操作系统这门课程，打开了 Linux 的大门，折腾了很久，也算一个 Linux 入门选手。我是从 Ubuntu 桌面版开始接触 Linux 的，Ubuntu 桌面版集成了很多软件，入手简单易学，但不可避免显得很臃肿，虽然可以手动删除很多不需要的东西，但这个过程很麻烦，甚至于你无法把它删减成最简洁的系统，这对于有强迫症的我来说无法忍受。后来我转向 Arch，Arch 最大的特点是做加法，从安装开始，它一步步安装内核、固件、基础软件包，然后添加一些能用到的基本功能，从一开始，Arch 就遵循最简洁的原则，我需要的就是安装这样一个最简洁的系统。</p><p>使用 Arch Linux，你会学到很多关于 Linux 的知识，从安装开始，就是一个怎样一步步将系统跑起来的指南，分区、挂载、安装、配置……当你仔细阅读这些细节，一定会受益匪浅。给我的感觉是 Ubuntu 桌面版这种操作系统是从系统整体层面切入，而 Arch 是深入到包层面，目前我的学习阶段也只是深入到这个层面。当然，我不推荐使用基于Arch的 Manjaro，因为它失去了这种优势，变得和 Ubuntu 桌面版一样了。如果再深入学习，可以选择 Gentoo，从编译开始，可以说是深入源码层面了。</p><p>上面这个对比我只是从学习角度来比较的，稳定性暂时不考虑。以我的使用感受来说，Ubuntu 也有很多小问题，Arch 也没有出现过崩溃到需要重装系统的问题。出于好奇，我喜欢安装各种不同的图形界面，毕竟华丽的外表很有吸引力，但是图形界面有很多 Bug，这与 Linux 图形界面显示机制和硬件驱动有一定关系。</p><p>Arch 适合有一定 Linux 基础的人使用，定制化强就意味着很折腾，一直想记录下这个过程，搁置了很久，最近有时间了，打算记录一下，一方面以备以后查询，另一方面，给入手 Arch 的同学一个参考。</p><p>Linux 作为日常办公使用具有局限性，但在服务器上表现十分优秀。不可否认 Windows 也是一款优秀的桌面操作系统，我们日常使用的软件很多都只有 Windows 版本，而且日常使用的 Office 办公软件也都绑定在 Windows 上，尽管 Linux 也可以实现类似的功能，但实际操作过程与格式转换比较麻烦，所以我不打算把 Linux 系统作为日常办公系统。</p><p>学习使用 Linux，首先需要掌握一些基础知识，如常用命令、多用户模式、文件权限、常用软件使用等。Linux 系统上小问题可能比较多，遇到这些 bug，解决过程可能很复杂。另外养成随手保存和经常整理、备份资料的好习惯，不至于在系统出现故障时造成损失。</p><p>Linux 发行版=Linux 内核+包管理工具+桌面环境</p><p><img src="/img/linux/linux_distributions.png" alt="linux distributions"></p><p>Linux 发行版</p><p>从表面来看，各个 Linux 发行版不同之处在于发行版集成的工具、包管理工具以及软件仓库的不同，而不是桌面环境（DE）的不同，当然还有稳定性、服务等方面的不同。</p><p>常见的 Linux 发行版有 Ubuntu、Fedora、openSUSE、Debian、Mint、CentOS、Arch、Gentoo、Deepin。</p><h2 id="Arch简介">Arch简介</h2><p>Arch Linux 是通用 x86-64 GNU/Linux 发行版。Arch 采用滚动升级模式，尽全力提供最新的稳定版软件。初始安装的 Arch 只是一个基本系统，随后用户可以根据自己的喜好安装需要的软件并配置成符合自己理想的系统.</p><h3 id="原则"><strong>原则</strong></h3><ul><li><strong>简洁</strong></li></ul><p>避免任何不必要的添加、修改和复杂增加。它提供的软件都来自原始开发者(上游)，仅进行和发行版(下游)相关的最小修改。简单来说，就是我们一步步添加自己需要的功能，不必要的东西完全不用安装，做到了系统最小化。</p><ul><li><strong>现代</strong></li></ul><p>Arch 尽全力保持软件处于最新的稳定版本，只要不出现系统软件包破损，都尽量用最新版本。Arch 采用滚动升级策略，安装之后可以持续升级。 Arch 向 GNU/Linux 用户提供了许多新特性，包括 systemd 初始化系统、现代的文件系统、LVM2/EVMS、软件磁盘阵列（软 RAID）、udev 支持、initcpio（附带 mkinitcpio）以及最新的内核。这个特点很激进，因为这种特性很容易造成不稳定，最新功能往往没有经过完整的测试，但也是这个功能，让你能用上最新的功能。很多在其他发行版中找不到的软件在Arch都能找到，只需一条命令就能安装。</p><ul><li><strong>通用</strong></li></ul><p>Arch Linux 是通用发行版，初始安装仅提供命令行环境：用户不需要删除大量不需要的软件包，而是可以从官方软件仓库成千上万的高质量软件包中进行选择，搭建自己的系统。支持x86-64 架构。( 对 i686 架构的支持已经结束 ） Arch有一个易用的包管理系统Pacman，仅凭一条命令就升级整个系统。Arch还提供一个类似ports的包构建系统（Arch Build System），通过它可以轻松从源码构建和安装软件包，并用一个命令完成同步。你甚至可以用一个命令重新构建整个系统。Arch还提供Arch 用户仓库，它包含了成千上万个由用户维护的PKGBUILD脚本，配合makepkg工具，从编译到打包一气呵成。用户还能轻松构建和维护属于自己的自定义软件源。</p><h2 id="参考资料">参考资料</h2><p><a href="http://link.zhihu.com/?target=https%3A//wiki.archlinux.org/title/Table_of_contents">Arch Wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux服务管理命令service与systemctl</title>
      <link href="/2021/07/24/linux-service-systemctl/"/>
      <url>/2021/07/24/linux-service-systemctl/</url>
      
        <content type="html"><![CDATA[<h2 id="历史背景">历史背景</h2><p>Linux 系统服务有时也称为守护程序，是在Linux启动时自动加载并在Linux退出时自动停止的系统任务。历史版本中的linux对服务的操作是通过service来完成的。若创建用户自定义的服务，则需要较为复杂的操作。目前linux新的发行版已经内置了systemctl来操作服务。</p><p>在早期服务管理中，Init 是Linux系统启动时创建的第一个进程。它是一个守护进程，会一直运行到系统关闭。init 是其他所有进程的直接或间接祖先，并自动监护所有孤儿进程。内核按照硬编码的文件名启动它，如果内核不能启动它，将会导致内核崩溃。init 的进程标识符（PID）通常是 1。在系统启动和关闭时，init 进程会启动 init 脚本（或称 rc）来保障基本功能。这包括挂载和卸载文件系统，以及启动守护进程。进一步，有一个服务管理器提供对已启动进程的主动控制，称为进程监控。例如监测崩溃的进程并适时重启。这些元素加起来就成了 init 系统。某些 init 将服务管理器包含在 init 进程中，或是有紧密联系的 init 脚本。在下面，这类 init 将被称为整合式的。其他的分类下的条目可能会相互依赖。</p><p>目前，很多Linux发行版转向了systemd。systemd 是一个 Linux 系统基础组件的集合，提供了一个系统和服务管理器，运行为 PID 1 并负责启动其它程序。功能包括：支持并行化任务；同时采用 socket 式与 D-Bus 总线式激活服务；按需启动守护进程（daemon）；利用 Linux 的 cgroups (简体中文) 监视进程；支持快照和系统恢复；维护挂载点和自动挂载点；各服务间基于依赖关系进行精密控制。systemd 支持 SysV 和 LSB 初始脚本，可以替代 sysvinit。除此之外，功能还包括日志进程、控制基础系统配置，维护登陆用户列表以及系统账户、运行时目录和设置，可以运行容器和虚拟机，可以简单的管理网络配置、网络时间同步、日志转发和名称解析等。</p><p>Init系统是一系列简单精小服务构成的集合，配置起来很复杂，但是配置过程透明。而systemd则是一个包含很多功能的庞大系统，配置简单，对于这个转换，各方争论不一，有人喜欢它的功能强大，操作简单，有人批评它不符合Unix哲学。</p><h2 id="service命令">service命令</h2><p>service是Init系统下进行服务管理的命令，service命令本身是一个shell脚本，它在/etc/init.d/目录查找指定的服务脚本，然后调用该服务脚本来完成任务。<br><img src="/img/linux/linux_service.png" alt="Service"></p><p>可通过sercice SCRIPT COMMAND命令管理服务，SCRIPT为/etc/init.d/中存放的可执行脚本文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service SCRIPT start    <span class="comment">#启动服务</span></span><br><span class="line">service SCRIPT stop     <span class="comment">#停止服务</span></span><br><span class="line">service SCRIPT restart  <span class="comment">#重启服务</span></span><br><span class="line">service SCRIPT status   <span class="comment">#查看状态服务</span></span><br></pre></td></tr></table></figure><p>此外还可以用service --status-all显示出所有系统服务列表，其中”+”代表服务正在运行，而”-“代表服务处于关闭状态，”?”代表根本没有状态这一说。<br>查看运行服务还可以用 ps aux | grep service_name查看进程情况；如果是网络服务，还可以查看端口的监听情况，执行 netstat -tuln | grep service_name/port_number,例如可以执行 netstat -tuln | grep ftp查看端口状态，默认端口为21。<br>用户可以添加自定义服务，将相应脚本放置于/etc/init.d/文件夹下。</p><h2 id="systemctl命令">systemctl命令</h2><h3 id="服务管理">服务管理</h3><p>systemctl是systemd系统下的服务管理命令。它包含的功能很多，详见<a href="https://man.archlinux.org/man/systemctl.1">systemctl</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">systemctl status   <span class="comment">#显示系统状态</span></span><br><span class="line">systemctl start [单元]  <span class="comment">#立即激活单元：</span></span><br><span class="line">systemctl stop [单元]   <span class="comment">#立即停止单元</span></span><br><span class="line">systemctl restart [单元] <span class="comment">#重启单元</span></span><br><span class="line">systemctl <span class="built_in">enable</span> [单元]  <span class="comment">#开机自动激活单元</span></span><br><span class="line">systemctl <span class="built_in">disable</span> [单元] <span class="comment">#取消开机自动激活单元</span></span><br><span class="line">systemctl daemon-reload  <span class="comment">#重新载入systemd，扫描新的或有变动的单元</span></span><br></pre></td></tr></table></figure><p>Systemd使用“单元（Unit）”监控管理系统，单元文件是 ini 风格的纯文本文件。 封装了有关下列对象的信息： 服务(service)、套接字(socket)、设备(device)、挂载点(mount)、自动挂载点(automount)、 启动目标(target)、交换分区或交换文件(swap)、被监视的路径(path)、任务计划(timer)、 资源控制组(slice)、一组外部创建的进程(scope)。有关单元详细介绍参见<a href="http://www.jinbuguo.com/systemd/systemd.unit.html">systemd.unit 中文手册</a>．</p><p>能用systemctl管理的服务需要有一个.service文件，在Ubuntu中，通常该文件位于/etc/systemd/system文件夹下，有关Systemd服务单元参见<a href="http://www.jinbuguo.com/systemd/systemd.service.html">systemd.service 中文手册</a>．<br><img src="/img/linux/linux_systemctl.png" alt="在这里插入图片描述"><br>当你更改了相关服务配置文件后，需要运行以下命令重启服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload &amp;&amp; sudo systemctl restart name</span><br><span class="line"><span class="comment"># 其中name为你要重启的服务</span></span><br></pre></td></tr></table></figure><h3 id="systemd-目标">systemd 目标</h3><p>Systemd中目标的概念，systemd 目标由目标单元表示。目标单元文件以 .target 文件扩展名结尾，它们的唯一用途是通过依赖项链将其他 systemd 单元分组在一起。例如，用于启动图形会话的 graphical.target 单元 将启动系统服务，如 GNOME 显示管理器 (gdm.service) 或帐户服务 (accounts-daemon.service)，还激活 multi-user.target 单元。同样，multi-user.target 单元会启动其他基本系统服务，如 NetworkManager (NetworkManager.service)或 D-Bus (dbus.service)，并激活另一个名为 basic.target 的目标单元。该模式替代了SysV init中预定义的运行级别。</p><p><strong>SysV 运行级别与 systemd 目标的比较</strong></p><table><thead><tr><th>运行级别</th><th>目标单元</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>runlevel0.target, poweroff.target</td><td>关闭系统</td></tr><tr><td>1</td><td>runlevel1.target, rescue.target</td><td>设置救援 shell</td></tr><tr><td>2</td><td>runlevel2.target, multi-user.target</td><td>设置一个非图形化的多用户系统</td></tr><tr><td>3</td><td>runlevel3.target, multi-user.target</td><td>设置一个非图形化的多用户系统</td></tr><tr><td>4</td><td>runlevel4.target, multi-user.target</td><td>设置一个非图形化的多用户系统</td></tr><tr><td>5</td><td>runlevel5.target, graphical.target</td><td>设置图形化多用户系统</td></tr><tr><td>6</td><td>runlevel6.target, reboot.target</td><td>关闭并重启系统</td></tr></tbody></table><p>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysvinit 运行级别</span></span><br><span class="line">runlevel   <span class="comment">#查看当前运行级别</span></span><br><span class="line">init N     <span class="comment">#进入其它运行级别</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># systemd 目标</span></span><br><span class="line">systemctl list-units --<span class="built_in">type</span>=target  <span class="comment">#列出了当前加载的和激活的目标</span></span><br><span class="line">systemctl isolate graphical.target  <span class="comment">#切换目标</span></span><br></pre></td></tr></table></figure><h3 id="日志功能">日志功能</h3><p>此外，systemd提供了日志功能，查看日志是我们寻找问题的重要方法。journalctl 用来查询 systemd-journald 服务收集到的日志。systemd-journald 服务是 systemd init 系统提供的收集系统日志的服务`</p><p>日志功能常用命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">journalctl            <span class="comment">#不带任何选项时，默认输出所有的日志记录</span></span><br><span class="line">journalctl -n [num]   <span class="comment">#显示最后num行的日志，如果省略num,则默认显示最后10行</span></span><br><span class="line">journalctl -f         <span class="comment">#实时滚动显示最新日志</span></span><br><span class="line">journalctl -u [unit]  <span class="comment">#显示指定unit的日志</span></span><br></pre></td></tr></table></figure><p>查看日志需要超级管理员权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 具体用法参见</span></span><br><span class="line">journalctl -h</span><br><span class="line"><span class="comment"># 例如查看docker服务最新日志</span></span><br><span class="line">sudo journalctl -u docker | <span class="built_in">tail</span> -n 50</span><br></pre></td></tr></table></figure><h2 id="参考文献">参考文献</h2><p><a href="https://wiki.archlinux.org/title/Systemd_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">systemd (简体中文)</a><br><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/configuring_basic_system_settings/working-with-systemd-targets_configuring-basic-system-settings">使用 systemd 目标</a><br><a href="https://www.cnblogs.com/sparkdev/p/8795141.html">linux journalctl 命令</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Service </tag>
            
            <tag> Systemctl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 异步编程 Promise</title>
      <link href="/2021/07/22/javascript-promise/"/>
      <url>/2021/07/22/javascript-promise/</url>
      
        <content type="html"><![CDATA[<h2 id="异步编程">异步编程</h2><p>通常来说，程序都是顺序执行的，同一时刻只会发生一件事。如果一个函数依赖于另一个函数的结果，它只能等待那个函数结束才能继续执行，从用户的角度来说，整个程序才算运行完毕。</p><h3 id="线程">线程</h3><p>一个线程是一个基本的处理过程，程序用它来完成任务。每个线程一次只能执行一个任务:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Task A --&gt; Task B --&gt; Task C  </span><br></pre></td></tr></table></figure><p>每个任务顺序执行，只有前面的结束了，后面的才能开始。<br>现在的计算机大都有多个内核（core），因此可以同时执行多个任务。支持多线程的编程语言可以使用计算机的多个内核，同时完成多个任务:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread 1: Task A --&gt; Task C  </span><br><span class="line">Thread 2: Task B --&gt; Task D  </span><br></pre></td></tr></table></figure><p>一个程序，通常从Main方法开始，我们称此线程称为主线程（main thread）。</p><h3 id="异步概念">异步概念</h3><p>如果程序调用某个方法，等待其执行全部处理后才能继续执行，我们称其为同步的。相反，在处理完成之前就返回调用方法则是异步的。<br>在使用同步编程方式时，由于每个线程同时只能发起一个请求并同步等待返回，这种等待不仅使程序变慢，而且浪费了计算机资源，所以为了提高系统性能，此时我们就需要引入更多的线程来实现并行化处理，这就是异步编程的出发点。<br>异步编程是可以让程序并行运行的一种手段，其可以让程序中的一个工作单元与主应用程序线程分开独立运行，并且在工作单元运行结束后，会通知主应用程序线程它的运行结果或者失败原因。使用异步编程可以提高应用程序的性能和响应能力等。</p><h3 id="异步编程的分类">异步编程的分类</h3><p>JavaScript 传统上是单线程的，经过不断完善，JavaScript 获得了一些工具来帮助解决这种问题。解决异步问题方法大致包括：直接回调、pub/sub模式(事件模式)、异步库控制库(例如async、when)、promise、Generator等。</p><h2 id="Promise-对象">Promise 对象</h2><p>Promise 是异步编程的一种解决方案，比传统的解决方案回调函数和事件更合理和更强大。<br>Promise对象有以下两个特点：</p><ul><li>对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</li><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li></ul><h3 id="基本用法">基本用法</h3><p>Promise使用实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">asyncDo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve,reject</span>)&#123;</span><br><span class="line">        <span class="comment">// some codes</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="comment">/*异步操作成功*/</span>)&#123;</span><br><span class="line">            <span class="title function_">resolve</span>(value); <span class="comment">//异步操作成功，将value传递出去</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="title function_">reject</span>(erroe);  <span class="comment">//异步操作失败，报出错误，将error传递出去</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。<br>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。<br>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">asyncDo</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">    <span class="comment">//value为异步结果成功时，resolve传递出的参数</span></span><br><span class="line">    <span class="comment">//对异步结果成功时的操作</span></span><br><span class="line">&#125;，<span class="keyword">function</span>(<span class="params">error</span>)&#123;</span><br><span class="line">    <span class="comment">//error为异步结果失败时，reject传递出的参数</span></span><br><span class="line">    <span class="comment">//对异步结果失败时的操作    </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。这两个函数都是可选的，不一定要提供。它们都接受Promise对象传出的值作为参数。<br>一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 后面的语句不会执行</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise-prototype-then">Promise.prototype.then()</h3><p>Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。then方法返回的是一个新的Promise实例，因此可以采用链式写法，即then方法后面再调用另一个then方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;./1.json&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">post</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getJSON</span>(post.<span class="property">commentURL</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">comments</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolved: &quot;</span>, comments);</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">err</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rejected: &quot;</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用第一个回调函数，如果状态变为rejected，就调用第二个回调函数。</p><h3 id="Promise-prototype-catch">Promise.prototype.catch()</h3><p>Promise.prototype.catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&#x27;/posts.json&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">posts</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发生错误！&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，getJSON()方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then()方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch()方法指定的回调函数，处理这个错误。另外，then()方法指定的回调函数，如果运行中抛出错误，也会被catch()方法捕获。</p><h3 id="Promise-prototype-finally">Promise.prototype.finally()</h3><p>finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。</p><hr><p>详细内容参见<a href="https://es6.ruanyifeng.com/#docs/promise">Promise 对象</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>终端下载工具wget与curl</title>
      <link href="/2021/07/20/wget-curl/"/>
      <url>/2021/07/20/wget-curl/</url>
      
        <content type="html"><![CDATA[<p>Wget工具与Curl工具都用来与服务器之间传输数据，有时候也用来测试网络连接。通常Wget多用于下载文件，Curl多用于测试网络的连通性。</p><h1>Wget命令</h1><h2 id="概述">概述</h2><p>GNU Wget 是一个免费实用程序，用于从 Web 非交互式下载文件。它支持HTTP、HTTPS和FTP协议，以及通过HTTP代理检索。下载地址为<a href="http://www.gnu.org/software/wget/">http://www.gnu.org/software/wget/</a></p><p>Wget 有如下特性：</p><ul><li>Wget 是非交互式的，这意味着它可以在后台工作，而用户未登录。这允许你开始检索并断开与系统的连接，让 Wget 完成工作。相比之下，大多数 Web 浏览器都需要用户始终在场，这在传输大量数据时会是一个很大的障碍。</li><li>wget 可以跟踪HTML页面上的链接依次下载来创建远程服务器的本地版本，完全重建原始站点的目录结构。这又常被称作”递归下载”。</li><li>wget 非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性.如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。</li></ul><p>详细内容参见<a href="http://www.gnu.org/software/wget/manual/">Wget手册</a></p><h2 id="调用">调用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget [option]… [URL]…</span><br></pre></td></tr></table></figure><h3 id="网络格式">网络格式</h3><p>URL是统一资源定位器的首字母缩写词。统一资源定位符是通过 Internet 提供的资源的紧凑字符串表示。Wget根据RFC1738识别URL语法 。这是最广泛使用的形式（方括号表示可选部分）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://host[:port]/directory/file</span><br><span class="line">ftp://host[:port]/directory/file</span><br></pre></td></tr></table></figure><p>还可以在 URL 中对用户名和密码进行编码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ftp://user:password@host/path</span><br><span class="line">http://user:password@host/path</span><br></pre></td></tr></table></figure><p>无论用户或密码，或两者，可以被排除在外。如果省略HTTP用户名或密码，则不会发送任何身份验证。如果省略FTP用户名，‘匿名的’ 将会被使用。如果省略FTP密码，你的电子邮件地址将作为默认密码提供。</p><h3 id="常见用法">常见用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget -O filename URL           <span class="comment"># 保存文件为 filename</span></span><br><span class="line">wget -c URL                    <span class="comment"># 断点续传</span></span><br><span class="line">wget -c -r -np -nc -L -p URL   <span class="comment"># 递归下载文件</span></span><br></pre></td></tr></table></figure><h3 id="常用选项">常用选项</h3><p>长选项所必须的参数在使用短选项时也是必须的。<br>启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-h,  --<span class="built_in">help</span>              <span class="comment">#打印此帮助。</span></span><br><span class="line">-b,  --background        <span class="comment">#启动后转入后台。</span></span><br></pre></td></tr></table></figure><p>日志和输入文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-d,  --debug               <span class="comment">#打印大量调试信息</span></span><br><span class="line">-q,  --quiet               <span class="comment">#安静模式 (无信息输出)</span></span><br><span class="line">-v,  --verbose             <span class="comment">#详尽的输出 (此为默认值)</span></span><br><span class="line">-nv, --no-verbose          <span class="comment">#关闭详尽输出，但不进入安静模式</span></span><br></pre></td></tr></table></figure><p>下载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-t,  --tries=NUMBER            <span class="comment">#设置重试次数为 NUMBER (0 代表无限制)</span></span><br><span class="line">     --retry-connrefused       <span class="comment">#即使拒绝连接也是重试</span></span><br><span class="line">-O,  --output-document=FILE    <span class="comment">#将文档写入 FILE</span></span><br><span class="line">-nc, --no-clobber              <span class="comment">#不要重复下载已存在的文件</span></span><br><span class="line">-c,  --<span class="built_in">continue</span>                <span class="comment">#断点续传下载文件</span></span><br><span class="line">     --no-proxy                <span class="comment">#禁止使用代理</span></span><br></pre></td></tr></table></figure><p>目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-nd, --no-directories           <span class="comment">#不创建目录</span></span><br><span class="line">-x,  --force-directories        <span class="comment">#强制创建目录</span></span><br><span class="line">-nH, --no-host-directories      <span class="comment">#不要创建主目录</span></span><br><span class="line">-P,  --directory-prefix=PREFIX  <span class="comment">#以 PREFIX/... 保存文件</span></span><br><span class="line">     --cut-dirs=NUMBER          <span class="comment">#忽略远程目录中 NUMBER 个目录层</span></span><br></pre></td></tr></table></figure><h1>Curl工具</h1><h2 id="简介">简介</h2><p>curl是一个非常强大的工具，它用来与服务器之间传输数据，其支持的协议包括 (DICT, FILE, FTP, FTPS, GOPHER, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, TELNET and TFTP)，curl设计为无用户图形界面交互下完成工作。<br>curl提供了一大堆非常有用的功能，包括代理访问、用户认证、ftp上传下载、HTTP POST、SSL连接、cookie支持、断点续传。<br>curl可用于多种平台，不仅仅是Linux平台，其官方网址为<a href="https://curl.se">https://curl.se</a></p><h2 id="安装">安装</h2><p>以Ubuntu20.04为例，可以采取源码包安装方式，下载对应平台源码压缩包，解压后放在合适位置，然后添加环境变量；为简单起见，可通过apt命令安装二进制包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install curl</span><br></pre></td></tr></table></figure><h2 id="curl用法详解">curl用法详解</h2><h3 id="命令格式">命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl [options] [URLs]</span><br></pre></td></tr></table></figure><h3 id="常见用法-2">常见用法</h3><p>1、显示网页</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://curl.se</span><br></pre></td></tr></table></figure><p>执行该命令，<a href="https://curl.se">https://curl.se</a> 页面以html格式显示在屏幕上，由于安装linux的时候很多时候是没有安装桌面的，也意味着没有浏览器，因此这个方法也经常用于测试一台服务器是否可以到达一个网站，此外，常用于测试终端代理是否成功。<br>2、下载文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl https://curl.se &gt;&gt; curl.html  <span class="comment">#使用linux的重定向功能保存</span></span><br><span class="line">curl -o curl.html https://curl.se  <span class="comment">#使用curl的内置option:-o(小写)保存文件</span></span><br><span class="line">curl -O https://curl.se  <span class="comment">#使用curl的内置option:-O(大写)保存文件，这里的url要具体到某个文件，不然下载不下来</span></span><br></pre></td></tr></table></figure><p>3、下载github文件<br>下载github仓库里一个具体文件方法如下，首先找到源文件链接：<br><img src="/img/linux/github_raw_download.png" alt="github raw download"><br>如上图所示，点击raw找到源文件链接，然后按照上述方式下载文件。</p><h3 id="其他参数">其他参数</h3><p>curl命令参数非常多，此处只介绍常用的几项即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-C/--continue-at &lt;offset&gt;             <span class="comment">#断点续转</span></span><br><span class="line">-f/--fail                             <span class="comment">#连接失败时不显示http错误</span></span><br><span class="line">-o/--output                           <span class="comment">#把输出写到该文件中</span></span><br><span class="line">-O/--remote-name                      <span class="comment">#把输出写到该文件中，保留远程文件的文件名</span></span><br><span class="line">-s/--silent                           <span class="comment">#静音模式，不输出任何东西</span></span><br><span class="line">-T/--upload-file &lt;file&gt;               <span class="comment">#上传文件</span></span><br><span class="line">-u/--user &lt;user[:password]&gt;           <span class="comment">#设置服务器的用户和密码</span></span><br><span class="line">-x/--proxy &lt;host[:port]&gt;              <span class="comment">#在给定的端口上使用HTTP代理</span></span><br><span class="line">-<span class="comment">#/--progress-bar                     #进度条显示当前的传送状态</span></span><br></pre></td></tr></table></figure><p>其他参数可以参考<a href="https://curl.se/docs/manpage.html">How to Use</a>文档。</p><h1>Httpie工具</h1><p>curl与wget诞生于很早之前，虽然如此，它们依旧功能强大。现在也有很多有意思的新项目，比如HTTPie（读作 —aitch-tee-tee-pie—）——一个命令行 HTTP 客户端，拥有直观的界面，支持 JSON、语法高亮、下载功能（类似 wget）、插件支持等特性，其GitHub项目地址为<a href="https://github.com/httpie/httpie">https://github.com/httpie/httpie</a>．</p><p>其设计目标是让 CLI 和 Web Service 的交互变得更友好。它提供了一个简单的 http 命令，可以让我们用简单且自然的语法发送任意 HTTP 请求，并且可以输出具有高亮显示的请求结果。HTTPie 可用于测试、调试以及通用的与 HTTP 服务器进行交互的场景。</p><p>apt软件源描述如下：<br><img src="https://img-blog.csdnimg.cn/e37dc8e21ba4420887d75d115facc3bf.png" alt="在这里插入图片描述"><br>HTTPie 详细介绍参见<a href="https://httpie.cn/doc/">HTTPie 中文文档</a>．</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 中 static 与 final 关键字</title>
      <link href="/2021/07/15/java-static-final/"/>
      <url>/2021/07/15/java-static-final/</url>
      
        <content type="html"><![CDATA[<h2 id="static关键字">static关键字</h2><p>Java中<strong>static</strong>关键字可以用来修饰类的成员变量和成员方法，此外，还可以编写static代码块来优化程序性能。</p><h3 id="static成员变量">static成员变量</h3><p>static变量也称作静态变量，静态变量和非静态变量的区别是：</p><ul><li>静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。</li><li>而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</li></ul><p>static成员变量的初始化顺序按照定义的顺序进行初始化。<br>static成员变量的定义方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DataType1 data1;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DataType2 data2;</span><br><span class="line"><span class="keyword">static</span> DataType3 data3;</span><br></pre></td></tr></table></figure><h3 id="static成员方法">static成员方法</h3><p>static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this、super的，因为它不依附于任何对象，既然都没有对象，就谈不上this、super了。<br>在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用，但是在非静态成员方法中是可以访问静态成员方法/变量的。</p><p>静态成员属于类,有两种方式可以引用静态成员：</p><ul><li>在引用该静态成员时，通常不需要生成该类的对象，而是通过类名直接引用。引用的方法是“类名 . 静态成员名”。</li><li>当然仍然可以通过“对象名 . 静态成员名”的方式引用该静态成员变量。</li></ul><h3 id="static代码块">static代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;      <span class="comment">//静态代码块</span></span><br><span class="line">        Employee.name=<span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">        Employee.gender=<span class="string">&quot;male&quot;</span>;</span><br><span class="line">        Employee.age=<span class="number">27</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>static代码块又称为静态代码块，或静态初始化器。它是在类中独立于成员函数的代码块。static代码块不需要程序主动调用，在JVM加载类时系统会执行 static代码块，因此在static代码块中可以做一些类成员变量的初始化工作。如果一个类中有多个 static代码块，JVM将会按顺序依次执行。需要注意的是，所有的static代码块只能在JVM加载类时被执行一次。</p><h3 id="static内部类">static内部类</h3><p>在内部类前添加修饰符static，这个内部类就变成为静态内部类了。</p><ul><li>一个静态内部类中可以声明static成员，但是在非静态内部类中不可以声明静态成员。</li><li>静态内部类不可以使用外部类的非静态成员。</li><li>静态成员内部类的特点主要是它本身是类相关的内部类，所以它可以不依赖于外部类实例而被实例化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is a static class.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="static成员加载顺序">static成员加载顺序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test static&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;base static&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;base constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">base static</span><br><span class="line">test static</span><br><span class="line">base constructor</span><br><span class="line">test constructor</span><br></pre></td></tr></table></figure><p>分析这段代码的执行过程：</p><ul><li>找到main方法入口，main方法是程序入口，但在执行main方法之前，要先加载Test类；</li><li>加载Test类的时候，发现Test类继承Base类，于是先去加载Base类；</li><li>加载Base类的时候，发现Base类有static块，而是先执行static块，输出base static结果；</li><li>Base类加载完成后，再去加载Test类，发现Test类也有static块，而是执行Test类中的static块，输出test static结果；</li><li>Base类和Test类加载完成后，然后执行main方法中的new Test()，调用子类构造器之前会先调用父类构造器；</li><li>调用父类构造器，输出base constructor结果；</li><li>再调用子类构造器，输出test constructor结果。</li></ul><h2 id="final关键字">final关键字</h2><p>在Java中，<strong>final</strong>关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）。</p><h3 id="final变量">final变量</h3><p>用final关键字修饰的变量，只能进行一次赋值操作，并且在生存期内不可以改变它的值。final修饰的变量可以先声明，后赋值。<br>当用final作用于类的成员变量时，成员变量必须在定义时或者构造器中进行初始化赋值，final作用于局部变量只需要保证在使用之前被初始化赋值即可。<br>对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">double</span> PI=<span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> VALUE_1=<span class="number">100</span>; <span class="comment">//一个既是static又是final的字段只占据一段不能改变的存储空间。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="keyword">final</span> VALUE_2=<span class="number">10</span>; <span class="comment">//在Java中定义全局变量，通常使用public static final修饰。</span></span><br></pre></td></tr></table></figure><h3 id="final方法">final方法</h3><p>final关键字修饰方法，它表示该方法不能被覆盖（重写）。另外，类中所有的private方法都隐式地指定为是final的，由于无法在类外使用private方法，所以也就无法覆盖它。此时可以在子类中定义相同的方法名和参数，这种情况不再产生重写与final的矛盾，而是在子类中重新定义了新的方法。可以对private方法添加final修饰符，但并没有添加任何额外意义。</p><h3 id="final方法参数">final方法参数</h3><p>编写方法时，可以在参数前面添加final关键字，它表示在整个方法中，不会（实际上是不能）改变参数的值，具体类似于修饰数据。即不能改变参数的值，但是可以改变引用类型参数的对象的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> a,<span class="keyword">final</span> String b)</span>;</span><br><span class="line"><span class="comment">//a不能被改变，b所指向的引用不能被改变。</span></span><br></pre></td></tr></table></figure><h3 id="final类">final类</h3><p>定义为final的类不能被继承。如果希望一个类不被任何类继承，并且不允许其他人对这个类进行任何改动，可以将这个类设置为final形式，final类的语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ExmapleClass&#123;&#125;</span><br></pre></td></tr></table></figure><p>如果将某个类设置为final形式，则类中的所有方法都被隐式设置为final形式，但是final类中的成员变量可以被定义为final或非final形式。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有关 Java 对象的理解</title>
      <link href="/2021/07/09/java-object/"/>
      <url>/2021/07/09/java-object/</url>
      
        <content type="html"><![CDATA[<p>基于《Java编程思想》（<em>Thinking in Java Fourth Edition</em>）整理，记录学习所获。阅读《Java编程思想》需要有一定编程基础，最好提前了解过一些有关C++编程的知识。</p><hr><h3 id="前言">前言</h3><p>尽管Java是基于C++的，但相比之下，Java是一种更“纯粹”的面向对象程序设计语言。</p><p>C++和Java都是混合/杂合型语言。杂合型语言允许多种编程风格；C++之所以成为一种杂合型语言主要是因为它支持与C语言的向后兼容，使C++在某些方面显得过于复杂。</p><h3 id="用引用操作对象">用引用操作对象</h3><p>在Java中，一切都被视为对象，操纵的标识符实际上是对象的一个<strong>引用</strong>（reference），Java中的引用在语法上更接近C++的引用而不是指针。创建一个String引用语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str;</span><br></pre></td></tr></table></figure><h3 id="必须由你创建所有对象">必须由你创建所有对象</h3><p>上面所创建的只是引用，并不是对象，也就是说引用并不一定要和对象关联，可以独立存在，但在使用它的时候必须与特定对象关联，通常使用<strong>new</strong>操作符来实现这一目的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str;</span><br><span class="line">str = <span class="keyword">new</span> <span class="title class_">String</span>();</span><br></pre></td></tr></table></figure><p>或者我们也可以将上述两条语句合在一起写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Sring</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br></pre></td></tr></table></figure><h4 id="存储到什么地方">存储到什么地方</h4><ul><li><strong>寄存器</strong><br>位于处理器内部，最快的存储区域，不能直接控制（C和C++允许向编译器建议寄存器分配方式）。</li><li><strong>堆栈</strong><br>位于RAM（随机访问存储器）中，是一种快速有效的存储分配方式，仅次于寄存器。某些Java数据特别是对象引用存储于堆栈中。Java必须知道存储在堆栈里所有项的确切生命周期，以便于上下移动堆栈指针。</li><li><strong>堆</strong><br>一种通用内存池（也位于RAM区域），用于存放所有Java对象，堆不同于堆栈的好处是：编译器不需要知道存储的数据在堆里存活多长时间。</li><li><strong>常量存储</strong><br>常量值通常直接存放在程序代码内部。</li><li><strong>非RAM存储</strong><br>数据完全存活于程序之外，两个基本的例子是<strong>流对象</strong>和<strong>持久化对象</strong>。把对象转化成可以存放在其他媒介上的事物，在需要时，可恢复成常规的、基于RAM的对象。</li></ul><h4 id="特例：基本类型">特例：基本类型</h4><p>如int、char、double等基本数据类型不用new操作符创建变量，而是创建一个并非是引用的<strong>自动变量</strong>，这个变量直接存储“值”，并置于堆栈中，因此更加有效。<strong>Java每种基本类型所占存储空间是固定的，不像其他大多数程序设计语言那样随机器硬件架构的变化而变化</strong>。<br>基本类型具有的包装器类，使得可以在堆中创建一个非基本对象，用来表示对应的基本类型。<br>Java提供了两个用于高精度计算的类：BigInteger和BigDecimal，二者没有对应的基本类型。</p><h4 id="Java中的数组">Java中的数组</h4><p>Java确保数组会被初始化，而且不能在它的范围之外被访问。当创建一个数组对象时，实际上创建了一个数组引用，并且每个引用都会被初始化为null，在使用之前，必须为其指定一个对象。创建的基本数组初始化全部置零。</p><h3 id="永远不需要销毁的对象">永远不需要销毁的对象</h3><p>Java有一个垃圾回收器，用来监视new创建的所有对象，并辨别那些不会再被引用的对象。随后吧，释放这些对象的内存空间，以便供其他新的对象使用。</p><h3 id="创建新的数据类型">创建新的数据类型</h3><p>用<strong>class</strong>关键字声明类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ATypeName</span>&#123;</span><br><span class="line">    <span class="comment">/* Class body goes here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字段和方法">字段和方法</h4><ul><li><strong>字段</strong>：数据成员</li><li><strong>方法</strong>：成员函数</li></ul><p>引用一个对象的成员的方法为：在对象引用的名称后紧接着一个句点（.），然后再接着是对象内部的成员名称：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objectReference.member</span><br><span class="line">objectReference1.objectReference2.member <span class="comment">//objectReference2是objectReference1的成员</span></span><br></pre></td></tr></table></figure><h4 id="基本成员默认值">基本成员默认值</h4><p>若类的某个成员是基本数据，即使没有初始化，Java也会确保它获得一个默认值（C++不具有此特性）。对于局部变量，Java则不会初始化为默认值，在使用局部变量前必须初始化，否则编译器会报错。</p><h3 id="方法、参数和返回值">方法、参数和返回值</h3><p>方法名和参数列表（它们合起来被称为“方法签名”）唯一的标识出某个方法。<br>Java中传递的参数是引用。</p><h3 id="构建一个Java程序">构建一个Java程序</h3><h4 id="名字可见性">名字可见性</h4><p>为了给一个类库生成不会与其他名字混淆的名字，Java设计者采用反过来使用自己的Internet域名，可以保证独一无二，句点就用来代表子目录的划分。</p><h4 id="运用其他构件">运用其他构件</h4><p>Java使用关键字<strong>import</strong>指示编译器导入一个包，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.*;   <span class="comment">//使用通配符导入导入多个类</span></span><br></pre></td></tr></table></figure><p>java.lang会自动导入到所有源程序中。</p><h4 id="static关键字">static关键字</h4><p>当遇到两种情形：</p><ul><li>只想为某特定域分配单一存储空间，而不去考虑究竟要创建多少对象，甚至根本不用创建任何对象。</li><li>希望某个方法不与包含它的类的任何对象关联在一起，也就是说，即使没有创建对象，也能够调用这个方法。</li></ul><p>通过<strong>static</strong>关键字可以满足这两方面需求，当声明一个事物是static时，就意味着这个域或方法不会与包含它的那个类的任何对象实例关联在一起。引用static变量有两种方法，可以通过一个对象去定位它，如：ObjectName.member，或者也可以通过类名直接引用，如ClassName.member。<br>量有两种方法，可以通过一个对象去定位它，如：ObjectName.member，或者也可以通过类名直接引用，如ClassName.member。<br>当static作用于某个字段时，会改变数据的创建方式（一个static字段对每个类来说都只有一分存储空间，而非static字段则是对每个对象有一个存储空间），但是static作用于方法，差别却没有那么大，static方法的一个重要用法就是在不创建任何对象的前提下就可以去调用它。static方法的这种特性很像全局方法。<br><strong>在static方法内部不能调用非static方法和使用非static数据成员。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 18 中安装 GCC 编译器</title>
      <link href="/2020/07/14/ubuntu-instal-gcc/"/>
      <url>/2020/07/14/ubuntu-instal-gcc/</url>
      
        <content type="html"><![CDATA[<p>该文章是小编刚开始接触Linux的第一篇文章，那个时候连cd、ls…… 这些基本命令还没搞明白，现在回看，不免有些不当之处，现予以修改。</p><h1>软件安装模式</h1><p>Linux中安装软件一般有两种方式：</p><ol><li>源码包，源码包是在本机上完成编译安装，根据具体硬件编译，相对于直接安装二进制包性能上有一定的提升，但安装过程比较繁琐，需要手动输入命令编译，初学者实操难度比较高。</li><li>二进制包，在Ubuntu中为.deb包，为编译好了的程序，安装过程简单。</li></ol> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载的.deb包可以通过dpkg命令安装</span></span><br><span class="line">sudo dpkg -i install-example-version.deb</span><br></pre></td></tr></table></figure><h1>包管理软件</h1><p>Linux操作系统都提供了一种中心化的机制用来搜索和安装软件。软件通常都是存放在存储库中，并通过包的形式进行分发。处理包的工作被称为包管理。包提供了操作系统的基本组件，以及共享的库、应用程序、服务和文档。包管理系统除了安装软件外，它还提供了工具来更新已经安装的包。包存储库有助于确保你的系统中使用的代码是经过审查的，并且软件的安装版本已经得到了开发人员和包维护人员的认可。</p><p>包管理软件自动处理软件之间的依赖关系，在Ubuntu系统中，包管理命令是apt，它集合了传统的apt-get 和 apt-cache等命令的大部分功能。</p><h1>GCC简介</h1><p>通常所说的GCC是GUN Compiler Collection的简称，是由GNU开发的编程语言编译器。GNU编译器套件包括C、C++、 Objective-C、 Fortran、Java、Ada和Go语言前端，也包括了这些语言的库。GCC的初衷是为GNU操作系统专门编写的一款编译器。GNU系统是彻底的自由软件。大家可以进入<a href="http://gcc.gnu.org/">GCC官网</a>查看相关信息。</p><h1>安装步骤</h1><ol><li>在终端输入</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install build-essential</span><br></pre></td></tr></table></figure><p>build-essential是一整套工具，执行完后，就完成了gcc,g++,make的安装。</p><ol start="2"><li>检查是否安装成功</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -v</span><br></pre></td></tr></table></figure><p>若出现gcc版本号，则证明安装成功</p><h1>常见问题</h1><p>这里列举一个我在安装过程中遇到的问题，在执行完sudo apt install build-essential后，出现了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hemu@ubuntu:~$ sudo apt install build-essential</span><br><span class="line">...</span><br><span class="line">The following packages have unmet dependencies:</span><br><span class="line"> build-essential : Depends: libc6-dev but it is not going to be installed or</span><br><span class="line">                            libc-dev</span><br><span class="line">                   Depends: g++ (&gt;= 4:4.4.3) but it is not going to be installed</span><br><span class="line">E: Unable to correct problems, you have held broken packages.</span><br></pre></td></tr></table></figure><p>为什么会出现这个问题呢，当时小编也很懵，明明按照教程一步一步做的，而我却出现了bug。现在就来探究一下问题的根源，由于众所周知的原因，国内访问Ubuntu官方软件源很慢，所以需要更换软件源，小编就百度了一下“Ubuntu更换软件源”，也没多想就随便找了一篇教程把软件源粘贴上去了，结果，小编用的是Ubuntu18.04，软件源对应“bionic”仓库，却粘贴成了Ubuntu16.04的“xenial”仓库，可想而知，软件版本之间发生了冲突，经过小编这么长时间的探索发现，手动安装软件很多时候bug都是由软件版本之间不匹配引起的。</p><p>关于Ubuntu版本的命名规则和开发代号，Ubuntu版本的命名规则是根据正式版发布的年月命名，Ubuntu18.04LTS 也就意味着 2018年4月发布的 Ubuntu，有LTS的为长期维护版本。Ubuntu 的开发代号有三个特点：</p><ol><li>都是动物</li><li>都是两个词，并且两个词的首字母相同</li><li>从6.06开始，首字母从D开始递增</li></ol><p>比如Ubuntu18.04LTS的开发代号为Bionic Beaver，所以其官方软件源为：<br>deb <a href="http://cn.archive.ubuntu.com/ubuntu/">http://cn.archive.ubuntu.com/ubuntu/</a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder accentunder="true"><mrow><mi>b</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>i</mi><mi>c</mi></mrow><mo stretchy="true">‾</mo></munder></mrow><annotation encoding="application/x-tex">\underline{bionic}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.89444em;vertical-align:-0.20000000000000007em;"></span><span class="mord underline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-2.84em;"><span class="pstrut" style="height:3em;"></span><span class="underline-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.20000000000000007em;"><span></span></span></span></span></span></span></span></span> main restricted universe multiverse</p><p>接下来我们需要将其更换为国内软件源，/etc/apt/sources.list文件即为系统软件源列表，我们首先将其备份。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/apt</span><br><span class="line">sudo <span class="built_in">cp</span> sources.list sources.list.bak</span><br><span class="line">sudo vim sources.list</span><br></pre></td></tr></table></figure><p>然后从<a href="https://developer.aliyun.com/mirror/">阿里巴巴开源镜像站 - 阿里云开发者社区</a>中寻找相对应的软件源，例如Ubuntu18.04LTS为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后更新一下软件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><p>然后在安装gcc。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> GCC </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
